Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Loaded SDL version 2.0.13-5893924
/usr/share/themes/Breeze-Dark/gtk-2.0/widgets/entry:70: error: unexpected identifier `direction', expected character `}'

(steam:58171): Gtk-WARNING **: Unable to locate theme engine in module_path: "adwaita",
/usr/share/themes/Breeze-Dark/gtk-2.0/widgets/styles:36: error: invalid string constant "combobox_entry", expected valid string constant
Installing breakpad exception handler for appid(steam)/version(1596217132)
Fontconfig warning: line 5: unknown element "its:rules"
Fontconfig warning: line 6: unknown element "its:translateRule"
Fontconfig warning: line 9: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/10-hinting-slight.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/10-scale-bitmap-fonts.conf", line 4: unknown element "description"
Fontconfig error: "/etc/fonts/conf.d/10-scale-bitmap-fonts.conf", line 72: non-double matrix element
Fontconfig error: "/etc/fonts/conf.d/10-scale-bitmap-fonts.conf", line 72: non-double matrix element
Fontconfig warning: "/etc/fonts/conf.d/10-scale-bitmap-fonts.conf", line 80: saw unknown, expected number
Fontconfig warning: "/etc/fonts/conf.d/20-unhint-small-vera.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/30-metric-aliases.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/40-nonlatin.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/45-generic.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/45-latin.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/49-sansserif.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/50-user.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/51-local.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/60-generic.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/60-latin.conf", line 4: unknown element "description"
Fontconfig warning: "/etc/fonts/conf.d/65-nonlatin.conf", line 4: unknown element "description"
[0826/230942.981496:INFO:crash_reporting.cc(247)] Crash reporting enabled for process: browser
[0826/230942.997102:WARNING:crash_reporting.cc(286)] Failed to set crash key: UserID with value: 0
[0826/230942.997152:WARNING:crash_reporting.cc(286)] Failed to set crash key: BuildID with value: 1596186727
[0826/230942.997156:WARNING:crash_reporting.cc(286)] Failed to set crash key: SteamUniverse with value: Public
[0826/230942.997159:WARNING:crash_reporting.cc(286)] Failed to set crash key: Vendor with value: Valve
[0826/230943.021407:WARNING:crash_reporting.cc(286)] Failed to set crash key: UserID with value: 0
[0826/230943.021457:WARNING:crash_reporting.cc(286)] Failed to set crash key: BuildID with value: 1596186727
[0826/230943.021461:WARNING:crash_reporting.cc(286)] Failed to set crash key: SteamUniverse with value: Public
[0826/230943.021464:WARNING:crash_reporting.cc(286)] Failed to set crash key: Vendor with value: Valve
[0826/230943.021833:INFO:crash_reporting.cc(247)] Crash reporting enabled for process: gpu-process
[0826/230943.112456:ERROR:sandbox_linux.cc(372)] InitializeSandbox() called with multiple threads in process gpu-process.
[0826/230943.129602:WARNING:crash_reporting.cc(286)] Failed to set crash key: UserID with value: 0
[0826/230943.129651:WARNING:crash_reporting.cc(286)] Failed to set crash key: BuildID with value: 1596186727
[0826/230943.129655:WARNING:crash_reporting.cc(286)] Failed to set crash key: SteamUniverse with value: Public
[0826/230943.129658:WARNING:crash_reporting.cc(286)] Failed to set crash key: Vendor with value: Valve
[0826/230943.130031:INFO:crash_reporting.cc(247)] Crash reporting enabled for process: utility
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Warning: failed to set thread priority: set failed for 8: -1: setpriority() failed
Warning: failed to set thread priority: set failed for priority 8
Warning: support for elevated priorities is most likely unavailable, suppressing future warnings
Warning: failed to set thread priority: set failed for 8: -1: setpriority() failed
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Proceed to auto login
CApplicationManagerPopulateThread took 52 milliseconds to initialize (will have waited on CAppInfoCacheReadFromDiskThread)

** (steam:58171): WARNING **: Unknown device type 14

** (steam:58171): WARNING **: Could not create object for /org/freedesktop/NetworkManager/Devices/1: unknown object type
Installing breakpad exception handler for appid(steam)/version(1596217132)
CAppInfoCacheReadFromDiskThread took 114 milliseconds to initialize
Installing breakpad exception handler for appid(steam)/version(1596217132)
Opted-in Controller Mask for AppId 0: 0
Installing breakpad exception handler for appid(steam)/version(1596217132)

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'autoconnect-priority'

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'autoconnect-priority'

** (steam:58171): WARNING **: Ignoring invalid property 'interface-name'

** (steam:58171): WARNING **: Unknown setting 'proxy'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

** (steam:58171): WARNING **: Ignoring invalid property 'route-data'

** (steam:58171): WARNING **: Ignoring invalid property 'address-data'

(steam:58171): Gtk-WARNING **: gtk_disable_setlocale() must be called before gtk_init()
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Installing breakpad exception handler for appid(steam)/version(1596217132)
Failed to create /home/marijan/.local/share/Steam/shader_cache_temp_dir_vk_64/mesa_shader_cache for shader cache (Permission denied)---disabling.
WARNING: radv is not a conformant vulkan implementation, testing use only.
Fossilize INFO: Overriding serialization path: "/home/marijan/.local/share/Steam/shader_cache_temp_dir_vk_64/fozpipelinesv4/steamapprun_pipeline_cache".
roaming config store loaded successfully - 2489 bytes.
migrating temporary roaming config store
BRefreshApplicationsInLibrary 1: 14ms
[0826/230946.087841:INFO:crash_reporting.cc(270)] Crash reporting enabled for process: renderer
[0826/230946.137860:INFO:crash_reporting.cc(270)] Crash reporting enabled for process: renderer
[0826/230946.216714:INFO:crash_reporting.cc(270)] Crash reporting enabled for process: renderer
Installing breakpad exception handler for appid(steam)/version(1596217132)
Failed to init SteamVR because it isn't installed
ExecCommandLine: "'/home/marijan/.local/share/Steam/ubuntu12_32/steam' 'steam://run/48000'"
ExecuteSteamURL: "steam://run/48000"
System startup time: 3.66 seconds
[0826/230946.433820:INFO:crash_reporting.cc(270)] Crash reporting enabled for process: renderer
[0826/230946.436519:INFO:crash_reporting.cc(270)] Crash reporting enabled for process: renderer
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to ProcessingInstallScript with ""
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to SynchronizingCloud with ""
BuildCompleteAppOverviewChange: 370
RegisterForAppOverview 1: 11ms
RegisterForAppOverview 2: 11ms
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to SiteLicenseSeatCheckout with ""
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to CreatingProcess with ""
GameAction [AppID 48000, ActionID 1] : LaunchApp waiting for user response to CreatingProcess ""
GameAction [AppID 48000, ActionID 1] : LaunchApp continues with user response "CreatingProcess"
Opted-in Controller Mask for AppId 48000: 0
Game update: AppID 48000 "", ProcID 58591, IP 0.0.0.0:0
ERROR: ld.so: object '/home/marijan/.local/share/Steam/ubuntu12_32/gameoverlayrenderer.so' from LD_PRELOAD cannot be preloaded (wrong ELF class: ELFCLASS32): ignored.
Starting app 48000
Installing breakpad exception handler for appid(steam)/version(1596217132)
>>> Adding process 58591 for game ID 48000
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to WaitingGameWindow with ""
GameAction [AppID 48000, ActionID 1] : LaunchApp changed task to Completed with ""
ERROR: ld.so: object '/home/marijan/.local/share/Steam/ubuntu12_64/gameoverlayrenderer.so' from LD_PRELOAD cannot be preloaded (wrong ELF class: ELFCLASS64): ignored.
>>> Adding process 58592 for game ID 48000
Game update: AppID 48000 "", ProcID 58592, IP 0.0.0.0:0
RecordSteamInterfaceCreation (PID 58592): SteamUser017 / User
RecordSteamInterfaceCreation (PID 58592): SteamFriends014 / Friends
RecordSteamInterfaceCreation (PID 58592): SteamUtils007 / Utils
RecordSteamInterfaceCreation (PID 58592): SteamMatchMaking009 / Matchmaking
RecordSteamInterfaceCreation (PID 58592): SteamMatchMakingServers002 / MatchmakingServers
RecordSteamInterfaceCreation (PID 58592): STEAMUSERSTATS_INTERFACE_VERSION011 / UserStats
RecordSteamInterfaceCreation (PID 58592): STEAMAPPS_INTERFACE_VERSION006 / Apps
RecordSteamInterfaceCreation (PID 58592): SteamNetworking005 / Networking
RecordSteamInterfaceCreation (PID 58592): STEAMREMOTESTORAGE_INTERFACE_VERSION012 / RemoteStorage
RecordSteamInterfaceCreation (PID 58592): STEAMSCREENSHOTS_INTERFACE_VERSION002 / Screenshots
RecordSteamInterfaceCreation (PID 58592): STEAMHTTP_INTERFACE_VERSION002 / HTTP
RecordSteamInterfaceCreation (PID 58592): STEAMUNIFIEDMESSAGES_INTERFACE_VERSION001 / UnifiedMessages
RecordSteamInterfaceCreation (PID 58592): STEAMCONTROLLER_INTERFACE_VERSION / Controller
RecordSteamInterfaceCreation (PID 58592): STEAMUGC_INTERFACE_VERSION002 / UGC
RecordSteamInterfaceCreation (PID 58592): STEAMAPPLIST_INTERFACE_VERSION001 / AppList
RecordSteamInterfaceCreation (PID 58592): STEAMMUSIC_INTERFACE_VERSION001 / Music
Setting breakpad minidump AppID = 48000
Steam_SetMinidumpSteamID:  Caching Steam ID:  76561198237582120 [API loaded no]
shader: MESA_SHADER_COMPUTE
local-size: 64, 1, 1
shared-size: 0
inputs: 0
outputs: 0
uniforms: 0
shared: 0
decl_var ssbo INTERP_MODE_NONE readonly uint[] ssbo (0, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec3 32 ssa_0 = intrinsic load_work_group_id () ()
	vec3 32 ssa_1 = intrinsic load_local_invocation_id () ()
	vec1 32 ssa_2 = load_const (0x00000006 /* 0.000000 */)
	vec1 32 ssa_3 = ishl ssa_0.x, ssa_2
	vec1 32 ssa_4 = iadd ssa_3, ssa_1.x
	vec1 32 ssa_5 = load_const (0x00000004 /* 0.000000 */)
	vec1 32 ssa_6 = ishl ssa_4, ssa_5
	vec4 32 ssa_7 = intrinsic load_user_data_amd () ()
	vec1 32 ssa_8 = load_const (0x00000000 /* 0.000000 */)
	intrinsic store_ssbo (ssa_7, ssa_8, ssa_6) (15, 131, 4, 0) /* wrmask=xyzw */ /* access=131 */ /* align_mul=4 */ /* align_offset=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 1
Compute Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

@compute_lds = external addrspace(3) global [0 x i8], align 65536

define amdgpu_cs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, <4 x i32> inreg %4, i32 inreg %5, <3 x i32> %6) #0 {
main_body:
  %7 = shl i32 %5, 6
  %8 = extractelement <3 x i32> %6, i32 0
  %9 = add i32 %7, %8
  %10 = shl i32 %9, 4
  %11 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %2, i32 15, !amdgpu.uniform !0
  %12 = load <4 x i32>, <4 x i32> addrspace(6)* %11, align 16, !invariant.load !0
  %13 = bitcast <4 x i32> %4 to <4 x float>
  call void @llvm.amdgcn.raw.buffer.store.v4f32(<4 x float> %13, <4 x i32> %12, i32 %10, i32 0, i32 3) #2
  ret void
}

; Function Attrs: nounwind writeonly
declare void @llvm.amdgcn.raw.buffer.store.v4f32(<4 x float>, <4 x i32>, i32, i32, i32 immarg) #1

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="64,64" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind writeonly }
attributes #2 = { inaccessiblememonly nounwind }

!0 = !{}

SHADER KEY

Compute Shader:
Shader main disassembly:
main:
BB0_0:
	s_movk_i32 s3, 0x8000                                    ; B0038000
	s_lshl_b32 s8, s8, 6                                     ; 8F088608
	v_mov_b32_e32 v3, s6                                     ; 7E060206
	v_mov_b32_e32 v2, s5                                     ; 7E040205
	v_mov_b32_e32 v1, s4                                     ; 7E020204
	s_load_dwordx4 s[0:3], s[2:3], 0xf0                      ; F4080001 FA0000F0
	v_add_lshl_u32 v0, s8, v0, 4                             ; D7470000 02120008
	v_mov_b32_e32 v4, s7                                     ; 7E080207
	s_waitcnt lgkmcnt(0)                                     ; BF8CC07F
	buffer_store_dwordx4 v[1:4], v0, s[0:3], 0 offen glc slc ; E0785000 80400100
	s_endpgm                                                 ; BF810000

*** SHADER STATS ***
SGPRS: 16
VGPRS: 8
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 56 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_FRAGMENT
name: GLSL0
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_NONE vec4 gl_Color (VARYING_SLOT_COL0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec4 32 ssa_0 = intrinsic load_color0 () ()
	vec1 32 ssa_1 = deref_var &gl_FragColor (shader_out vec4) 
	intrinsic store_deref (ssa_1, ssa_0) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 2
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21, float %22, float %23, float %24, float %25) #0 {
main_body:
  %26 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %27 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %26, float %22, 5
  %28 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %27, float %23, 6
  %29 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %28, float %24, 7
  %30 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %29, float %25, 8
  %31 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %30, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %31
}

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }

shader: MESA_SHADER_VERTEX
name: ARB0
inputs: 3
outputs: 3
uniforms: 4
shared: 0
decl_var uniform INTERP_MODE_NONE vec4[4] state.matrix.mvp.transpose.row[0] (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 in_0 (VERT_ATTRIB_POS.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 in_2 (VERT_ATTRIB_COLOR0.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec4 in_15 (VERT_ATTRIB_POINT_SIZE.xyzw, 8, 0)
decl_var shader_out INTERP_MODE_NONE vec4 out_0 (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 out_1 (VARYING_SLOT_COL0.xyzw, 4, 0)
decl_var shader_out INTERP_MODE_NONE float out_12 (VARYING_SLOT_PSIZ.x, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &in_0 (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_3 = intrinsic load_ubo (ssa_2, ssa_2) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_4 = fmul ssa_1.x, ssa_3.x
	vec1 32 ssa_5 = fmul ssa_1.x, ssa_3.y
	vec1 32 ssa_6 = fmul ssa_1.x, ssa_3.z
	vec1 32 ssa_7 = fmul ssa_1.x, ssa_3.w
	vec1 32 ssa_8 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_2, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = ffma ssa_1.y, ssa_9.x, ssa_4
	vec1 32 ssa_11 = ffma ssa_1.y, ssa_9.y, ssa_5
	vec1 32 ssa_12 = ffma ssa_1.y, ssa_9.z, ssa_6
	vec1 32 ssa_13 = ffma ssa_1.y, ssa_9.w, ssa_7
	vec1 32 ssa_14 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_15 = intrinsic load_ubo (ssa_2, ssa_14) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_16 = ffma ssa_1.z, ssa_15.x, ssa_10
	vec1 32 ssa_17 = ffma ssa_1.z, ssa_15.y, ssa_11
	vec1 32 ssa_18 = ffma ssa_1.z, ssa_15.z, ssa_12
	vec1 32 ssa_19 = ffma ssa_1.z, ssa_15.w, ssa_13
	vec1 32 ssa_20 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_21 = intrinsic load_ubo (ssa_2, ssa_20) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_22 = ffma ssa_1.w, ssa_21.x, ssa_16
	vec1 32 ssa_23 = ffma ssa_1.w, ssa_21.y, ssa_17
	vec1 32 ssa_24 = ffma ssa_1.w, ssa_21.z, ssa_18
	vec1 32 ssa_25 = ffma ssa_1.w, ssa_21.w, ssa_19
	vec1 32 ssa_26 = deref_var &in_2 (shader_in vec4) 
	vec4 32 ssa_27 = intrinsic load_deref (ssa_26) (0) /* access=0 */
	vec1 32 ssa_28 = deref_var &in_15 (shader_in vec4) 
	vec4 32 ssa_29 = intrinsic load_deref (ssa_28) (0) /* access=0 */
	vec4 32 ssa_30 = vec4 ssa_22, ssa_23, ssa_24, ssa_25
	vec1 32 ssa_31 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_31, ssa_30) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_32 = deref_var &out_1 (shader_out vec4) 
	intrinsic store_deref (ssa_32, ssa_27) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_33 = mov ssa_29.x
	vec1 32 ssa_34 = deref_var &out_12 (shader_out float) 
	intrinsic store_deref (ssa_34, ssa_33) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 3
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %35 = and i32 %3, 251658240
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %37 = lshr i32 %2, 12
  %38 = and i32 %37, 511
  %39 = lshr i32 %2, 10
  %40 = and i32 %39, 2093056
  %41 = or i32 %40, %38
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %41) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %42 = lshr i32 %3, 8
  %43 = and i32 %42, 255
  %44 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %45 = icmp ult i32 %44, %43
  br i1 %45, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %46 = bitcast i32 %23 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %46, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %47 = and i32 %3, 255
  %48 = icmp ult i32 %44, %47
  br i1 %48, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %49 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %32, i32 0, i32 0, i32 0) #3
  %50 = extractelement <4 x float> %49, i32 0
  %51 = extractelement <4 x float> %49, i32 1
  %52 = extractelement <4 x float> %49, i32 2
  %53 = extractelement <4 x float> %49, i32 3
  %54 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %33, i32 0, i32 0, i32 0) #3
  %55 = call nsz arcp contract float @llvm.amdgcn.struct.buffer.load.format.f32(<4 x i32> %22, i32 %34, i32 0, i32 0, i32 0) #3
  %56 = ptrtoint float addrspace(6)* %10 to i32
  %57 = insertelement <4 x i32> <i32 undef, i32 32768, i32 64, i32 822177708>, i32 %56, i32 0
  %58 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 0, i32 0) #3
  %59 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 4, i32 0) #3
  %60 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 8, i32 0) #3
  %61 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 12, i32 0) #3
  %62 = fmul nsz arcp contract float %50, %58
  %63 = fmul nsz arcp contract float %50, %59
  %64 = fmul nsz arcp contract float %50, %60
  %65 = fmul nsz arcp contract float %50, %61
  %66 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 16, i32 0) #3
  %67 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 20, i32 0) #3
  %68 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 24, i32 0) #3
  %69 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 28, i32 0) #3
  %70 = call nsz arcp contract float @llvm.fma.f32(float %51, float %66, float %62) #3
  %71 = call nsz arcp contract float @llvm.fma.f32(float %51, float %67, float %63) #3
  %72 = call nsz arcp contract float @llvm.fma.f32(float %51, float %68, float %64) #3
  %73 = call nsz arcp contract float @llvm.fma.f32(float %51, float %69, float %65) #3
  %74 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 32, i32 0) #3
  %75 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 36, i32 0) #3
  %76 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 40, i32 0) #3
  %77 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 44, i32 0) #3
  %78 = call nsz arcp contract float @llvm.fma.f32(float %52, float %74, float %70) #3
  %79 = call nsz arcp contract float @llvm.fma.f32(float %52, float %75, float %71) #3
  %80 = call nsz arcp contract float @llvm.fma.f32(float %52, float %76, float %72) #3
  %81 = call nsz arcp contract float @llvm.fma.f32(float %52, float %77, float %73) #3
  %82 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 48, i32 0) #3
  %83 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 52, i32 0) #3
  %84 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 56, i32 0) #3
  %85 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %57, i32 60, i32 0) #3
  %86 = call nsz arcp contract float @llvm.fma.f32(float %53, float %82, float %78) #3
  %87 = call nsz arcp contract float @llvm.fma.f32(float %53, float %83, float %79) #3
  %88 = call nsz arcp contract float @llvm.fma.f32(float %53, float %84, float %80) #3
  %89 = call nsz arcp contract float @llvm.fma.f32(float %53, float %85, float %81) #3
  %90 = extractelement <4 x float> %54, i32 0
  %91 = extractelement <4 x float> %54, i32 1
  %92 = extractelement <4 x float> %54, i32 2
  %93 = extractelement <4 x float> %54, i32 3
  %94 = and i32 %12, 1
  %95 = icmp eq i32 %94, 0
  br i1 %95, label %endif6502, label %if6502

if6502:                                           ; preds = %if11500
  %96 = call nsz arcp contract float @llvm.maxnum.f32(float %90, float 0.000000e+00) #3
  %97 = call nsz arcp contract float @llvm.minnum.f32(float %96, float 1.000000e+00) #3
  %98 = call nsz arcp contract float @llvm.maxnum.f32(float %91, float 0.000000e+00) #3
  %99 = call nsz arcp contract float @llvm.minnum.f32(float %98, float 1.000000e+00) #3
  %100 = call nsz arcp contract float @llvm.maxnum.f32(float %92, float 0.000000e+00) #3
  %101 = call nsz arcp contract float @llvm.minnum.f32(float %100, float 1.000000e+00) #3
  %102 = call nsz arcp contract float @llvm.maxnum.f32(float %93, float 0.000000e+00) #3
  %103 = call nsz arcp contract float @llvm.minnum.f32(float %102, float 1.000000e+00) #3
  br label %endif6502

endif6502:                                        ; preds = %if11500, %if6502
  %.04 = phi float [ %97, %if6502 ], [ %90, %if11500 ]
  %.03 = phi float [ %99, %if6502 ], [ %91, %if11500 ]
  %.02 = phi float [ %101, %if6502 ], [ %92, %if11500 ]
  %.0 = phi float [ %103, %if6502 ], [ %93, %if11500 ]
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %86, float %87, float %88, float %89, i1 false, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 13, i32 1, float %55, float undef, float undef, float undef, i1 true, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %.04, float %.03, float %.02, float %.0, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %endif6502, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare float @llvm.amdgcn.struct.buffer.load.format.f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.maxnum.f32(float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.minnum.f32(float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_FLAT vec4 in_0 (VARYING_SLOT_VAR0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_1 = intrinsic load_input (ssa_0) (0, 0, 160) /* base=0 */ /* component=0 */ /* type=float32 */	/* in_0 */
	vec1 32 ssa_2 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_2, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 4
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 0, i32 0, i32 %5) #2
  %23 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 1, i32 0, i32 %5) #2
  %24 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 2, i32 0, i32 %5) #2
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 3, i32 0, i32 %5) #2
  %26 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %27 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %26, float %22, 5
  %28 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %27, float %23, 6
  %29 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %28, float %24, 7
  %30 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %29, float %25, 8
  %31 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %30, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %31
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.mov(i32, i32 immarg, i32 immarg, i32) #1

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }

shader: MESA_SHADER_VERTEX
inputs: 2
outputs: 2
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_FLAT vec4 in_0 (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_FLAT vec4 in_1 (VERT_ATTRIB_GENERIC1.xyzw, 4, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_1 (VARYING_SLOT_VAR0.xyzw, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &in_0 (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &in_1 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_4, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_5 = deref_var &out_1 (shader_out vec4) 
	intrinsic store_deref (ssa_5, ssa_3) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 5
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, i32 inreg %10, i32 inreg %11, float inreg %12, float inreg %13, float inreg %14, float inreg %15, float inreg %16, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %17, i32 %18, i32 %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %29 = and i32 %3, 251658240
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %31 = lshr i32 %2, 12
  %32 = and i32 %31, 511
  %33 = lshr i32 %2, 10
  %34 = and i32 %33, 2093056
  %35 = or i32 %34, %32
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %35) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %36 = lshr i32 %3, 8
  %37 = and i32 %36, 255
  %38 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %39 = icmp ult i32 %38, %37
  br i1 %39, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %40 = bitcast i32 %18 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %40, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %41 = and i32 %3, 255
  %42 = icmp ult i32 %38, %41
  br i1 %42, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %43 = icmp ult i32 %23, 2
  %44 = icmp eq i32 %23, 1
  %.v.v = select i1 %43, i32 %10, i32 %11
  %.v = shl i32 %.v.v, 16
  %45 = ashr exact i32 %.v, 16
  %.v2 = select i1 %44, i32 %11, i32 %10
  %46 = ashr i32 %.v2, 16
  %47 = sitofp i32 %45 to float
  %48 = sitofp i32 %46 to float
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %47, float %48, float %12, float 1.000000e+00, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %13, float %14, float %15, float %16, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }

!0 = !{i32 0, i32 32}

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                                               ; BEFE03C1
	s_and_b32 s0, s3, 0xf000000                                                         ; 8700FF03 0F000000
	s_cmp_lg_u32 s0, 0                                                                  ; BF078000
	s_cbranch_scc1 BB0_2                                                                ; BF850000
	s_lshr_b32 s0, s2, 10                                                               ; 90008A02
	s_bfe_u32 s1, s2, 0x9000c                                                           ; 9381FF02 0009000C
	s_and_b32 s0, s0, 0x1ff000                                                          ; 8700FF00 001FF000
	s_or_b32 m0, s0, s1                                                                 ; 887C0100
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                                                 ; BF900009
BB0_2:
	s_bfe_u32 s0, s3, 0x80008                                                           ; 9380FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                                                    ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_4                                                               ; BF880000
BB0_3:
	exp prim v0, off, off, off done                                                     ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                                                 ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s0                                                       ; 887E007E
	s_and_b32 s0, s3, 0xff                                                              ; 8700FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_6                                                               ; BF880000
BB0_5:
	v_mov_b32_e32 v0, s10                                                               ; 7E00020A
	v_cmp_gt_u32_e32 vcc_lo, 2, v5                                                      ; 7D880A82
	v_mov_b32_e32 v1, s11                                                               ; 7E02020B
	v_mov_b32_e32 v2, 1.0                                                               ; 7E0402F2
	v_mov_b32_e32 v3, s12                                                               ; 7E06020C
	v_cndmask_b32_e32 v0, s11, v0, vcc_lo                                               ; 0200000B
	v_cmp_eq_u32_e32 vcc_lo, 1, v5                                                      ; 7D840A81
	v_cvt_f32_i32_sdwa v0, sext(v0) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_0 ; 7E000AF9 000C0600
	v_cndmask_b32_e32 v1, s10, v1, vcc_lo                                               ; 0202020A
	v_cvt_f32_i32_sdwa v1, sext(v1) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_1 ; 7E020AF9 000D0601
	exp pos0 v0, v1, v3, v2 done vm                                                     ; F80018CF 02030100
	s_waitcnt expcnt(0)                                                                 ; BF8CFF0F
	v_mov_b32_e32 v0, s13                                                               ; 7E00020D
	v_mov_b32_e32 v1, s14                                                               ; 7E02020E
	v_mov_b32_e32 v2, s15                                                               ; 7E04020F
	v_mov_b32_e32 v3, s16                                                               ; 7E060210
	exp param0 v0, v1, v2, v3                                                           ; F800020F 03020100
BB0_6:
	s_endpgm                                                                            ; BF810000

*** SHADER STATS ***
SGPRS: 24
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 200 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


radeonsi: Compiling shader 6
Fragment Shader Epilog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps void @ps_epilog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, float inreg %4, float %5, float %6, float %7, float %8, float %9, float %10, float %11, float %12, float %13, float %14, float %15, float %16, float %17, float %18, float %19) #0 {
main_body:
  %20 = call nsz arcp contract <2 x half> @llvm.amdgcn.cvt.pkrtz(float %5, float %6) #3
  %21 = call nsz arcp contract <2 x half> @llvm.amdgcn.cvt.pkrtz(float %7, float %8) #3
  %22 = bitcast <2 x half> %20 to <2 x i16>
  %23 = bitcast <2 x half> %21 to <2 x i16>
  call void @llvm.amdgcn.exp.compr.v2i16(i32 0, i32 15, <2 x i16> %22, <2 x i16> %23, i1 true, i1 true) #4
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare <2 x half> @llvm.amdgcn.cvt.pkrtz(float, float) #1

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.compr.v2i16(i32 immarg, i32 immarg, <2 x i16>, <2 x i16>, i1 immarg, i1 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xffffff" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { inaccessiblememonly nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { nounwind }

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 7
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 m0, s5                     ; BEFC0305
	v_interp_mov_f32_e32 v0, p0, attr0.x ; C8020002
	v_interp_mov_f32_e32 v1, p0, attr0.y ; C8060102
	v_interp_mov_f32_e32 v2, p0, attr0.z ; C80A0202
	v_interp_mov_f32_e32 v3, p0, attr0.w ; C80E0302
Shader epilog disassembly:
ps_epilog:
BB0_0:
	v_cvt_pkrtz_f16_f32_e32 v2, v2, v3    ; 5E040702
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	exp mrt0 v0, v0, v2, v2 done compr vm ; F8001C0F 00000200
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0020
*** SHADER STATS ***
SGPRS: 8
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 40 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_VERTEX
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_FLAT vec4 in_0 (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (VARYING_SLOT_POS.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &in_0 (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_2, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 7
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, i32 inreg %10, i32 inreg %11, float inreg %12, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %13, i32 %14, i32 %15, i32 %16, i32 %17, i32 %18, i32 %19, i32 %20, i32 %21, i32 %22, i32 %23) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %24 = and i32 %3, 251658240
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %26 = lshr i32 %2, 12
  %27 = and i32 %26, 511
  %28 = lshr i32 %2, 10
  %29 = and i32 %28, 2093056
  %30 = or i32 %29, %27
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %30) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %31 = lshr i32 %3, 8
  %32 = and i32 %31, 255
  %33 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %34 = icmp ult i32 %33, %32
  br i1 %34, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %35 = bitcast i32 %14 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %35, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %36 = and i32 %3, 255
  %37 = icmp ult i32 %33, %36
  br i1 %37, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %38 = icmp ult i32 %19, 2
  %39 = icmp eq i32 %19, 1
  %.v.v = select i1 %38, i32 %10, i32 %11
  %.v = shl i32 %.v.v, 16
  %40 = ashr exact i32 %.v, 16
  %.v2 = select i1 %39, i32 %11, i32 %10
  %41 = ashr i32 %.v2, 16
  %42 = sitofp i32 %40 to float
  %43 = sitofp i32 %41 to float
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %42, float %43, float %12, float 1.000000e+00, i1 true, i1 true) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }

!0 = !{i32 0, i32 32}

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                                               ; BEFE03C1
	s_and_b32 s0, s3, 0xf000000                                                         ; 8700FF03 0F000000
	s_cmp_lg_u32 s0, 0                                                                  ; BF078000
	s_cbranch_scc1 BB0_2                                                                ; BF850000
	s_lshr_b32 s0, s2, 10                                                               ; 90008A02
	s_bfe_u32 s1, s2, 0x9000c                                                           ; 9381FF02 0009000C
	s_and_b32 s0, s0, 0x1ff000                                                          ; 8700FF00 001FF000
	s_or_b32 m0, s0, s1                                                                 ; 887C0100
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                                                 ; BF900009
BB0_2:
	s_bfe_u32 s0, s3, 0x80008                                                           ; 9380FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                                                    ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_4                                                               ; BF880000
BB0_3:
	exp prim v0, off, off, off done                                                     ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                                                 ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s0                                                       ; 887E007E
	s_and_b32 s0, s3, 0xff                                                              ; 8700FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_6                                                               ; BF880000
BB0_5:
	v_mov_b32_e32 v0, s10                                                               ; 7E00020A
	v_cmp_gt_u32_e32 vcc_lo, 2, v5                                                      ; 7D880A82
	v_mov_b32_e32 v1, s11                                                               ; 7E02020B
	v_mov_b32_e32 v2, 1.0                                                               ; 7E0402F2
	v_mov_b32_e32 v3, s12                                                               ; 7E06020C
	v_cndmask_b32_e32 v0, s11, v0, vcc_lo                                               ; 0200000B
	v_cmp_eq_u32_e32 vcc_lo, 1, v5                                                      ; 7D840A81
	v_cvt_f32_i32_sdwa v0, sext(v0) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_0 ; 7E000AF9 000C0600
	v_cndmask_b32_e32 v1, s10, v1, vcc_lo                                               ; 0202020A
	v_cvt_f32_i32_sdwa v1, sext(v1) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_1 ; 7E020AF9 000D0601
	exp pos0 v0, v1, v3, v2 done vm                                                     ; F80018CF 02030100
BB0_6:
	s_endpgm                                                                            ; BF810000

*** SHADER STATS ***
SGPRS: 16
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 172 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


radeonsi: Compiling shader 8
Fragment Shader Epilog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps void @ps_epilog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, float inreg %4, float %5, float %6, float %7, float %8, float %9, float %10, float %11, float %12, float %13, float %14, float %15, float %16, float %17, float %18, float %19) #0 {
main_body:
  call void @llvm.amdgcn.exp.f32(i32 9, i32 0, float undef, float undef, float undef, float undef, i1 true, i1 true) #2
  ret void
}

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #1

attributes #0 = { "InitialPSInputAddr"="0xffffff" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { inaccessiblememonly nounwind }
attributes #2 = { nounwind }

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x0
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 7
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 m0, s5                     ; BEFC0305
	v_interp_mov_f32_e32 v0, p0, attr0.x ; C8020002
	v_interp_mov_f32_e32 v1, p0, attr0.y ; C8060102
	v_interp_mov_f32_e32 v2, p0, attr0.z ; C80A0202
	v_interp_mov_f32_e32 v3, p0, attr0.w ; C80E0302
Shader epilog disassembly:
ps_epilog:
BB1_0:
	exp null off, off, off, off done vm ; F8001890 00000000
	s_endpgm                            ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0020
*** SHADER STATS ***
SGPRS: 8
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 32 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_VERTEX
name: GLSL3
inputs: 2
outputs: 2
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 viewport (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@1 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@2 (VARYING_SLOT_VAR0.w, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_5 = load_const (0xc0000000 /* -2.000000 */)
	vec1 32 ssa_6 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_7 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_8 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_8, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = frcp ssa_9.z
	vec1 32 ssa_11 = frcp ssa_9.w
	vec1 32 ssa_12 = fmul ssa_1.x, ssa_10
	vec1 32 ssa_13 = fmul ssa_1.y, ssa_11
	vec1 32 ssa_14 = ffma ssa_12, ssa_4, ssa_6
	vec1 32 ssa_15 = ffma ssa_13, ssa_5, ssa_7
	vec1 32 ssa_16 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_17 = vec4 ssa_14, ssa_15, ssa_1.z, ssa_1.w
	intrinsic store_deref (ssa_16, ssa_17) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_18 = deref_var &v_diffuse (shader_out float) 
	vec1 32 ssa_19 = mov ssa_3.x
	intrinsic store_deref (ssa_18, ssa_19) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_20 = deref_var &v_diffuse@0 (shader_out float) 
	vec1 32 ssa_21 = mov ssa_3.y
	intrinsic store_deref (ssa_20, ssa_21) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_22 = deref_var &v_diffuse@1 (shader_out float) 
	vec1 32 ssa_23 = mov ssa_3.z
	intrinsic store_deref (ssa_22, ssa_23) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_24 = deref_var &v_diffuse@2 (shader_out float) 
	vec1 32 ssa_25 = mov ssa_3.w
	intrinsic store_deref (ssa_24, ssa_25) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 9
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = extractelement <4 x float> %47, i32 0
  %49 = extractelement <4 x float> %47, i32 1
  %50 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %51 = extractelement <4 x float> %50, i32 0
  %52 = extractelement <4 x float> %50, i32 1
  %53 = extractelement <4 x float> %50, i32 2
  %54 = extractelement <4 x float> %50, i32 3
  %55 = ptrtoint float addrspace(6)* %10 to i32
  %56 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %55, i32 0
  %57 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %56, i32 8, i32 0) #3
  %58 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %56, i32 12, i32 0) #3
  %59 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %57) #3
  %60 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %58) #3
  %61 = fmul nsz arcp contract float %48, %59
  %62 = fmul nsz arcp contract float %49, %60
  %63 = call nsz arcp contract float @llvm.fma.f32(float %61, float 2.000000e+00, float -1.000000e+00) #3
  %64 = call nsz arcp contract float @llvm.fma.f32(float %62, float -2.000000e+00, float 1.000000e+00) #3
  %65 = extractelement <4 x float> %47, i32 2
  %66 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %63, float %64, float %65, float %66, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %51, float %52, float %53, float %54, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #7

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL3
inputs: 1
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 textureFactor (1, 0, 0)
decl_var uniform INTERP_MODE_NONE float brightness (2, 4, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@1 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@2 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_diffuse */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_diffuse */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_diffuse */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_diffuse */
	vec1 32 ssa_6 = load_const (0x00000010 /* 0.000000 */)
	vec1 32 ssa_7 = intrinsic load_ubo (ssa_1, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec4 32 ssa_8 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_9 = fmul ssa_5, ssa_8.w
	vec1 32 ssa_10 = ffma ssa_2, ssa_8.x, ssa_7
	vec1 32 ssa_11 = ffma ssa_3, ssa_8.y, ssa_7
	vec1 32 ssa_12 = ffma ssa_4, ssa_8.z, ssa_7
	vec1 32 ssa_13 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_14 = vec4 ssa_10, ssa_11, ssa_12, ssa_9
	intrinsic store_deref (ssa_13, ssa_14) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 10
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #2
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #2
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #2
  %33 = ptrtoint float addrspace(6)* %2 to i32
  %34 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %33, i32 0
  %35 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 16, i32 0) #2
  %36 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 0, i32 0) #2
  %37 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 4, i32 0) #2
  %38 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 8, i32 0) #2
  %39 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 12, i32 0) #2
  %40 = fmul nsz arcp contract float %32, %39
  %41 = call nsz arcp contract float @llvm.fma.f32(float %26, float %36, float %35) #2
  %42 = call nsz arcp contract float @llvm.fma.f32(float %28, float %37, float %35) #2
  %43 = call nsz arcp contract float @llvm.fma.f32(float %30, float %38, float %35) #2
  %44 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %45 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %44, float %41, 5
  %46 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %45, float %42, 6
  %47 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %46, float %43, 7
  %48 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %47, float %40, 8
  %49 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %48, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %49
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readnone speculatable willreturn }

shader: MESA_SHADER_VERTEX
name: GLSL6
inputs: 3
outputs: 3
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 viewport (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 8, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@1 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_diffuse@2 (VARYING_SLOT_VAR0.w, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR1.x, 8, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0@3 (VARYING_SLOT_VAR1.y, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_5 = intrinsic load_deref (ssa_4) (0) /* access=0 */
	vec1 32 ssa_6 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_7 = load_const (0xc0000000 /* -2.000000 */)
	vec1 32 ssa_8 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_9 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_10 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_11 = intrinsic load_ubo (ssa_10, ssa_10) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_12 = frcp ssa_11.z
	vec1 32 ssa_13 = frcp ssa_11.w
	vec1 32 ssa_14 = fmul ssa_1.x, ssa_12
	vec1 32 ssa_15 = fmul ssa_1.y, ssa_13
	vec1 32 ssa_16 = ffma ssa_14, ssa_6, ssa_8
	vec1 32 ssa_17 = ffma ssa_15, ssa_7, ssa_9
	vec1 32 ssa_18 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_19 = vec4 ssa_16, ssa_17, ssa_1.z, ssa_1.w
	intrinsic store_deref (ssa_18, ssa_19) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_20 = deref_var &v_diffuse (shader_out float) 
	vec1 32 ssa_21 = mov ssa_3.x
	intrinsic store_deref (ssa_20, ssa_21) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_22 = deref_var &v_diffuse@0 (shader_out float) 
	vec1 32 ssa_23 = mov ssa_3.y
	intrinsic store_deref (ssa_22, ssa_23) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_24 = deref_var &v_diffuse@1 (shader_out float) 
	vec1 32 ssa_25 = mov ssa_3.z
	intrinsic store_deref (ssa_24, ssa_25) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_26 = deref_var &v_diffuse@2 (shader_out float) 
	vec1 32 ssa_27 = mov ssa_3.w
	intrinsic store_deref (ssa_26, ssa_27) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_28 = deref_var &v_uv0 (shader_out float) 
	vec1 32 ssa_29 = mov ssa_5.x
	intrinsic store_deref (ssa_28, ssa_29) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_30 = deref_var &v_uv0@3 (shader_out float) 
	vec1 32 ssa_31 = mov ssa_5.y
	intrinsic store_deref (ssa_30, ssa_31) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 11
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %35 = and i32 %3, 251658240
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %37 = lshr i32 %2, 12
  %38 = and i32 %37, 511
  %39 = lshr i32 %2, 10
  %40 = and i32 %39, 2093056
  %41 = or i32 %40, %38
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %41) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %42 = lshr i32 %3, 8
  %43 = and i32 %42, 255
  %44 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %45 = icmp ult i32 %44, %43
  br i1 %45, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %46 = bitcast i32 %23 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %46, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %47 = and i32 %3, 255
  %48 = icmp ult i32 %44, %47
  br i1 %48, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %49 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %32, i32 0, i32 0, i32 0) #3
  %50 = extractelement <4 x float> %49, i32 0
  %51 = extractelement <4 x float> %49, i32 1
  %52 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %33, i32 0, i32 0, i32 0) #3
  %53 = extractelement <4 x float> %52, i32 0
  %54 = extractelement <4 x float> %52, i32 1
  %55 = extractelement <4 x float> %52, i32 2
  %56 = extractelement <4 x float> %52, i32 3
  %57 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %22, i32 %34, i32 0, i32 0, i32 0) #3
  %58 = extractelement <2 x float> %57, i32 0
  %59 = extractelement <2 x float> %57, i32 1
  %60 = ptrtoint float addrspace(6)* %10 to i32
  %61 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %60, i32 0
  %62 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 8, i32 0) #3
  %63 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 12, i32 0) #3
  %64 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %62) #3
  %65 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %63) #3
  %66 = fmul nsz arcp contract float %50, %64
  %67 = fmul nsz arcp contract float %51, %65
  %68 = call nsz arcp contract float @llvm.fma.f32(float %66, float 2.000000e+00, float -1.000000e+00) #3
  %69 = call nsz arcp contract float @llvm.fma.f32(float %67, float -2.000000e+00, float 1.000000e+00) #3
  %70 = extractelement <4 x float> %49, i32 2
  %71 = extractelement <4 x float> %49, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %68, float %69, float %70, float %71, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %53, float %54, float %55, float %56, i1 false, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 33, i32 15, float %58, float %59, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #7

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL6
inputs: 2
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 textureFactor (1, 0, 0)
decl_var uniform INTERP_MODE_NONE float brightness (2, 4, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@1 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_diffuse@2 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@3 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_diffuse */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_diffuse */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_diffuse */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_diffuse */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_8 = load_const (0x00000010 /* 0.000000 */)
	vec1 32 ssa_9 = intrinsic load_ubo (ssa_1, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_11 = vec2 ssa_6, ssa_7
	vec4 32 ssa_12 = tex ssa_10 (texture_deref), ssa_10 (sampler_deref), ssa_11 (coord)
	vec1 32 ssa_13 = fmul ssa_12.x, ssa_2
	vec1 32 ssa_14 = fmul ssa_12.y, ssa_3
	vec1 32 ssa_15 = fmul ssa_12.z, ssa_4
	vec1 32 ssa_16 = fmul ssa_12.w, ssa_5
	vec4 32 ssa_17 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_18 = fmul ssa_16, ssa_17.w
	vec1 32 ssa_19 = ffma ssa_13, ssa_17.x, ssa_9
	vec1 32 ssa_20 = ffma ssa_14, ssa_17.y, ssa_9
	vec1 32 ssa_21 = ffma ssa_15, ssa_17.z, ssa_9
	vec1 32 ssa_22 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_23 = vec4 ssa_19, ssa_20, ssa_21, ssa_18
	intrinsic store_deref (ssa_22, ssa_23) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 12
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #2
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #2
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #2
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #2
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 0, i32 1, i32 %5) #2
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #2
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 1, i32 1, i32 %5) #2
  %37 = ptrtoint float addrspace(6)* %2 to i32
  %38 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %37, i32 0
  %39 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %38, i32 16, i32 0) #2
  %40 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %41 = load <8 x i32>, <8 x i32> addrspace(6)* %40, align 32, !invariant.load !0
  %42 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %43 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %42, i32 67, !amdgpu.uniform !0
  %44 = load <4 x i32>, <4 x i32> addrspace(6)* %43, align 16, !invariant.load !0
  %45 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %36, <8 x i32> %41, <4 x i32> %44, i1 false, i32 0, i32 0) #5
  %46 = extractelement <4 x float> %45, i32 0
  %47 = fmul nsz arcp contract float %46, %26
  %48 = extractelement <4 x float> %45, i32 1
  %49 = fmul nsz arcp contract float %48, %28
  %50 = extractelement <4 x float> %45, i32 2
  %51 = fmul nsz arcp contract float %50, %30
  %52 = extractelement <4 x float> %45, i32 3
  %53 = fmul nsz arcp contract float %52, %32
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %38, i32 0, i32 0) #2
  %55 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %38, i32 4, i32 0) #2
  %56 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %38, i32 8, i32 0) #2
  %57 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %38, i32 12, i32 0) #2
  %58 = fmul nsz arcp contract float %53, %57
  %59 = call nsz arcp contract float @llvm.fma.f32(float %47, float %54, float %39) #2
  %60 = call nsz arcp contract float @llvm.fma.f32(float %49, float %55, float %39) #2
  %61 = call nsz arcp contract float @llvm.fma.f32(float %51, float %56, float %39) #2
  %62 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %63 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %62, float %59, 5
  %64 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %63, float %60, 6
  %65 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %64, float %61, 7
  %66 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %65, float %58, 8
  %67 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %66, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %67
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #4

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL9
inputs: 2
outputs: 2
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 viewport (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_5 = load_const (0xc0000000 /* -2.000000 */)
	vec1 32 ssa_6 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_7 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_8 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_8, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = frcp ssa_9.z
	vec1 32 ssa_11 = frcp ssa_9.w
	vec1 32 ssa_12 = fmul ssa_1.x, ssa_10
	vec1 32 ssa_13 = fmul ssa_1.y, ssa_11
	vec1 32 ssa_14 = ffma ssa_12, ssa_4, ssa_6
	vec1 32 ssa_15 = ffma ssa_13, ssa_5, ssa_7
	vec1 32 ssa_16 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_17 = vec4 ssa_14, ssa_15, ssa_1.z, ssa_1.w
	intrinsic store_deref (ssa_16, ssa_17) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_18 = deref_var &v_uv0 (shader_out float) 
	vec1 32 ssa_19 = mov ssa_3.x
	intrinsic store_deref (ssa_18, ssa_19) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_20 = deref_var &v_uv0@0 (shader_out float) 
	vec1 32 ssa_21 = mov ssa_3.y
	intrinsic store_deref (ssa_20, ssa_21) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 13
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = extractelement <4 x float> %47, i32 0
  %49 = extractelement <4 x float> %47, i32 1
  %50 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %51 = extractelement <2 x float> %50, i32 0
  %52 = extractelement <2 x float> %50, i32 1
  %53 = ptrtoint float addrspace(6)* %10 to i32
  %54 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %53, i32 0
  %55 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %54, i32 8, i32 0) #3
  %56 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %54, i32 12, i32 0) #3
  %57 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %55) #3
  %58 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %56) #3
  %59 = fmul nsz arcp contract float %48, %57
  %60 = fmul nsz arcp contract float %49, %58
  %61 = call nsz arcp contract float @llvm.fma.f32(float %59, float 2.000000e+00, float -1.000000e+00) #3
  %62 = call nsz arcp contract float @llvm.fma.f32(float %60, float -2.000000e+00, float 1.000000e+00) #3
  %63 = extractelement <4 x float> %47, i32 2
  %64 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %61, float %62, float %63, float %64, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %51, float %52, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #7

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL9
inputs: 1
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 textureFactor (1, 0, 0)
decl_var uniform INTERP_MODE_NONE float brightness (2, 4, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_4 = load_const (0x00000010 /* 0.000000 */)
	vec1 32 ssa_5 = intrinsic load_ubo (ssa_1, ssa_4) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_6 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_7 = vec2 ssa_2, ssa_3
	vec4 32 ssa_8 = tex ssa_6 (texture_deref), ssa_6 (sampler_deref), ssa_7 (coord)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = fmul ssa_8.w, ssa_9.w
	vec1 32 ssa_11 = ffma ssa_8.x, ssa_9.x, ssa_5
	vec1 32 ssa_12 = ffma ssa_8.y, ssa_9.y, ssa_5
	vec1 32 ssa_13 = ffma ssa_8.z, ssa_9.z, ssa_5
	vec1 32 ssa_14 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_15 = vec4 ssa_11, ssa_12, ssa_13, ssa_10
	intrinsic store_deref (ssa_14, ssa_15) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 14
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #2
  %29 = ptrtoint float addrspace(6)* %2 to i32
  %30 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %29, i32 0
  %31 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %30, i32 16, i32 0) #2
  %32 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %33 = load <8 x i32>, <8 x i32> addrspace(6)* %32, align 32, !invariant.load !0
  %34 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %35 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %34, i32 67, !amdgpu.uniform !0
  %36 = load <4 x i32>, <4 x i32> addrspace(6)* %35, align 16, !invariant.load !0
  %37 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %33, <4 x i32> %36, i1 false, i32 0, i32 0) #5
  %38 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %30, i32 0, i32 0) #2
  %39 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %30, i32 4, i32 0) #2
  %40 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %30, i32 8, i32 0) #2
  %41 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %30, i32 12, i32 0) #2
  %42 = extractelement <4 x float> %37, i32 3
  %43 = fmul nsz arcp contract float %42, %41
  %44 = extractelement <4 x float> %37, i32 0
  %45 = call nsz arcp contract float @llvm.fma.f32(float %44, float %38, float %31) #2
  %46 = extractelement <4 x float> %37, i32 1
  %47 = call nsz arcp contract float @llvm.fma.f32(float %46, float %39, float %31) #2
  %48 = extractelement <4 x float> %37, i32 2
  %49 = call nsz arcp contract float @llvm.fma.f32(float %48, float %40, float %31) #2
  %50 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %51 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %50, float %45, 5
  %52 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %51, float %47, 6
  %53 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %52, float %49, 7
  %54 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %53, float %43, 8
  %55 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %54, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %55
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #4

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_FRAGMENT
name: GLSL12
inputs: 1
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 lBase (1, 0, 0)
decl_var uniform INTERP_MODE_NONE vec4 rBase (2, 4, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (4, 1, 1)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_4 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_5 = deref_var &texture1 (uniform sampler2D) 
	vec2 32 ssa_6 = vec2 ssa_2, ssa_3
	vec4 32 ssa_7 = tex ssa_5 (texture_deref), ssa_5 (sampler_deref), ssa_6 (coord)
	vec1 32 ssa_8 = deref_var &texture0 (uniform sampler2D) 
	vec4 32 ssa_9 = tex ssa_8 (texture_deref), ssa_8 (sampler_deref), ssa_6 (coord)
	vec1 32 ssa_10 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_11 = intrinsic load_ubo (ssa_1, ssa_10) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_12 = fmul ssa_7.y, ssa_11.y
	vec1 32 ssa_13 = ffma ssa_7.x, ssa_11.x, ssa_12
	vec1 32 ssa_14 = ffma ssa_7.z, ssa_11.z, ssa_13
	vec1 32 ssa_15 = ffma ssa_7.w, ssa_11.w, ssa_14
	vec4 32 ssa_16 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_17 = fmul ssa_7.y, ssa_16.y
	vec1 32 ssa_18 = ffma ssa_7.x, ssa_16.x, ssa_17
	vec1 32 ssa_19 = ffma ssa_7.z, ssa_16.z, ssa_18
	vec1 32 ssa_20 = ffma ssa_7.w, ssa_16.w, ssa_19
	vec1 32 ssa_21 = fneg ssa_20
	vec1 32 ssa_22 = fadd ssa_15, ssa_21
	vec1 32 ssa_23 = fabs ssa_22
	vec1 32 ssa_24 = fmin ssa_23, ssa_4
	vec1 32 ssa_25 = fneg ssa_24
	vec1 32 ssa_26 = fadd ssa_4, ssa_25
	vec1 32 ssa_27 = fmul ssa_9.y, ssa_11.y
	vec1 32 ssa_28 = ffma ssa_9.x, ssa_11.x, ssa_27
	vec1 32 ssa_29 = ffma ssa_9.z, ssa_11.z, ssa_28
	vec1 32 ssa_30 = ffma ssa_9.w, ssa_11.w, ssa_29
	vec1 32 ssa_31 = fmul ssa_9.y, ssa_16.y
	vec1 32 ssa_32 = ffma ssa_9.x, ssa_16.x, ssa_31
	vec1 32 ssa_33 = ffma ssa_9.z, ssa_16.z, ssa_32
	vec1 32 ssa_34 = ffma ssa_9.w, ssa_16.w, ssa_33
	vec1 32 ssa_35 = fneg ssa_34
	vec1 32 ssa_36 = fadd ssa_30, ssa_35
	vec1 32 ssa_37 = fabs ssa_36
	vec1 32 ssa_38 = fmin ssa_37, ssa_4
	vec1 32 ssa_39 = fneg ssa_38
	vec1 32 ssa_40 = fadd ssa_4, ssa_39
	vec1 32 ssa_41 = fmax ssa_7.x, ssa_7.y
	vec1 32 ssa_42 = fmax ssa_41, ssa_7.z
	vec1 32 ssa_43 = fmul ssa_24, ssa_42
	vec1 32 ssa_44 = ffma ssa_26, ssa_7.x, ssa_43
	vec1 32 ssa_45 = ffma ssa_26, ssa_7.y, ssa_43
	vec1 32 ssa_46 = ffma ssa_26, ssa_7.z, ssa_43
	vec1 32 ssa_47 = ffma ssa_26, ssa_7.w, ssa_43
	vec1 32 ssa_48 = fmax ssa_9.x, ssa_9.y
	vec1 32 ssa_49 = fmax ssa_48, ssa_9.z
	vec1 32 ssa_50 = fmul ssa_38, ssa_49
	vec1 32 ssa_51 = ffma ssa_40, ssa_9.x, ssa_50
	vec1 32 ssa_52 = ffma ssa_40, ssa_9.y, ssa_50
	vec1 32 ssa_53 = ffma ssa_40, ssa_9.z, ssa_50
	vec1 32 ssa_54 = ffma ssa_40, ssa_9.w, ssa_50
	vec1 32 ssa_55 = fmul ssa_51, ssa_16.x
	vec1 32 ssa_56 = fmul ssa_52, ssa_16.y
	vec1 32 ssa_57 = fmul ssa_53, ssa_16.z
	vec1 32 ssa_58 = fmul ssa_54, ssa_16.w
	vec1 32 ssa_59 = ffma ssa_44, ssa_11.x, ssa_55
	vec1 32 ssa_60 = ffma ssa_45, ssa_11.y, ssa_56
	vec1 32 ssa_61 = ffma ssa_46, ssa_11.z, ssa_57
	vec1 32 ssa_62 = ffma ssa_47, ssa_11.w, ssa_58
	vec1 32 ssa_63 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_64 = vec4 ssa_59, ssa_60, ssa_61, ssa_62
	intrinsic store_deref (ssa_63, ssa_64) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 15
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #3
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #3
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #3
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #3
  %29 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %30 = load <8 x i32>, <8 x i32> addrspace(6)* %29, align 32, !invariant.load !0
  %31 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %32 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %31, i32 71, !amdgpu.uniform !0
  %33 = load <4 x i32>, <4 x i32> addrspace(6)* %32, align 16, !invariant.load !0
  %34 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %30, <4 x i32> %33, i1 false, i32 0, i32 0) #5
  %35 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %36 = load <8 x i32>, <8 x i32> addrspace(6)* %35, align 32, !invariant.load !0
  %37 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %31, i32 67, !amdgpu.uniform !0
  %38 = load <4 x i32>, <4 x i32> addrspace(6)* %37, align 16, !invariant.load !0
  %39 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %36, <4 x i32> %38, i1 false, i32 0, i32 0) #5
  %40 = ptrtoint float addrspace(6)* %2 to i32
  %41 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %40, i32 0
  %42 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 16, i32 0) #3
  %43 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 20, i32 0) #3
  %44 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 24, i32 0) #3
  %45 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 28, i32 0) #3
  %46 = extractelement <4 x float> %34, i32 1
  %47 = fmul nsz arcp contract float %46, %43
  %48 = extractelement <4 x float> %34, i32 0
  %49 = call nsz arcp contract float @llvm.fma.f32(float %48, float %42, float %47) #3
  %50 = extractelement <4 x float> %34, i32 2
  %51 = call nsz arcp contract float @llvm.fma.f32(float %50, float %44, float %49) #3
  %52 = extractelement <4 x float> %34, i32 3
  %53 = call nsz arcp contract float @llvm.fma.f32(float %52, float %45, float %51) #3
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 0, i32 0) #3
  %55 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 4, i32 0) #3
  %56 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 8, i32 0) #3
  %57 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 12, i32 0) #3
  %58 = fmul nsz arcp contract float %46, %55
  %59 = call nsz arcp contract float @llvm.fma.f32(float %48, float %54, float %58) #3
  %60 = call nsz arcp contract float @llvm.fma.f32(float %50, float %56, float %59) #3
  %61 = call nsz arcp contract float @llvm.fma.f32(float %52, float %57, float %60) #3
  %62 = fsub nsz arcp contract float %53, %61
  %63 = call nsz arcp contract float @llvm.fabs.f32(float %62) #3
  %64 = call nsz arcp contract float @llvm.minnum.f32(float %63, float 1.000000e+00) #3
  %65 = fsub nsz arcp contract float 1.000000e+00, %64
  %66 = extractelement <4 x float> %39, i32 1
  %67 = fmul nsz arcp contract float %66, %43
  %68 = extractelement <4 x float> %39, i32 0
  %69 = call nsz arcp contract float @llvm.fma.f32(float %68, float %42, float %67) #3
  %70 = extractelement <4 x float> %39, i32 2
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float %44, float %69) #3
  %72 = extractelement <4 x float> %39, i32 3
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float %45, float %71) #3
  %74 = fmul nsz arcp contract float %66, %55
  %75 = call nsz arcp contract float @llvm.fma.f32(float %68, float %54, float %74) #3
  %76 = call nsz arcp contract float @llvm.fma.f32(float %70, float %56, float %75) #3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %72, float %57, float %76) #3
  %78 = fsub nsz arcp contract float %73, %77
  %79 = call nsz arcp contract float @llvm.fabs.f32(float %78) #3
  %80 = call nsz arcp contract float @llvm.minnum.f32(float %79, float 1.000000e+00) #3
  %81 = fsub nsz arcp contract float 1.000000e+00, %80
  %82 = call nsz arcp contract float @llvm.maxnum.f32(float %48, float %46) #3
  %83 = call nsz arcp contract float @llvm.maxnum.f32(float %82, float %50) #3
  %84 = fmul nsz arcp contract float %64, %83
  %85 = call nsz arcp contract float @llvm.fma.f32(float %65, float %48, float %84) #3
  %86 = call nsz arcp contract float @llvm.fma.f32(float %65, float %46, float %84) #3
  %87 = call nsz arcp contract float @llvm.fma.f32(float %65, float %50, float %84) #3
  %88 = call nsz arcp contract float @llvm.fma.f32(float %65, float %52, float %84) #3
  %89 = call nsz arcp contract float @llvm.maxnum.f32(float %68, float %66) #3
  %90 = call nsz arcp contract float @llvm.maxnum.f32(float %89, float %70) #3
  %91 = fmul nsz arcp contract float %80, %90
  %92 = call nsz arcp contract float @llvm.fma.f32(float %81, float %68, float %91) #3
  %93 = call nsz arcp contract float @llvm.fma.f32(float %81, float %66, float %91) #3
  %94 = call nsz arcp contract float @llvm.fma.f32(float %81, float %70, float %91) #3
  %95 = call nsz arcp contract float @llvm.fma.f32(float %81, float %72, float %91) #3
  %96 = fmul nsz arcp contract float %92, %54
  %97 = fmul nsz arcp contract float %93, %55
  %98 = fmul nsz arcp contract float %94, %56
  %99 = fmul nsz arcp contract float %95, %57
  %100 = call nsz arcp contract float @llvm.fma.f32(float %85, float %42, float %96) #3
  %101 = call nsz arcp contract float @llvm.fma.f32(float %86, float %43, float %97) #3
  %102 = call nsz arcp contract float @llvm.fma.f32(float %87, float %44, float %98) #3
  %103 = call nsz arcp contract float @llvm.fma.f32(float %88, float %45, float %99) #3
  %104 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %105 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %104, float %100, 5
  %106 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %105, float %101, 6
  %107 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %106, float %102, 7
  %108 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %107, float %103, 8
  %109 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %108, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %109
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fabs.f32(float) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.minnum.f32(float, float) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.maxnum.f32(float, float) #4

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_COMPUTE
local-size: 8, 8, 1
shared-size: 0
inputs: 0
outputs: 0
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4[2] uniform_0 (0, 0, 0)
decl_var uniform INTERP_MODE_NONE readonly r32g32b32a32_float image2DArray image (0, 0, 0)
decl_var uniform INTERP_MODE_NONE r32g32b32a32_float image2DArray image@0 (0, 0, 1)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = undefined
	vec1 32 ssa_1 = undefined
	vec1 32 ssa_2 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_3 = intrinsic load_ubo (ssa_2, ssa_2) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec3 32 ssa_4 = intrinsic load_work_group_id () ()
	vec3 32 ssa_5 = intrinsic load_local_invocation_id () ()
	vec1 32 ssa_6 = load_const (0x00000003 /* 0.000000 */)
	vec1 32 ssa_7 = ishl ssa_4.x, ssa_6
	vec1 32 ssa_8 = ishl ssa_4.y, ssa_6
	vec1 32 ssa_9 = iadd ssa_7, ssa_5.x
	vec1 32 ssa_10 = iadd ssa_8, ssa_5.y
	vec1 32 ssa_11 = iadd ssa_4.z, ssa_5.z
	vec1 32 ssa_12 = iadd ssa_9, ssa_3.x
	vec1 32 ssa_13 = iadd ssa_10, ssa_3.y
	vec1 32 ssa_14 = iadd ssa_11, ssa_3.z
	vec4 32 ssa_15 = vec4 ssa_12, ssa_13, ssa_14, ssa_12
	vec1 32 ssa_16 = deref_var &image (uniform image2DArray) 
	vec4 32 ssa_17 = intrinsic image_deref_load (ssa_16, ssa_15, ssa_1, ssa_2) (16) /* access=16 */
	vec1 32 ssa_18 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_19 = intrinsic load_ubo (ssa_2, ssa_18) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_20 = iadd ssa_9, ssa_19.x
	vec1 32 ssa_21 = iadd ssa_10, ssa_19.y
	vec1 32 ssa_22 = iadd ssa_11, ssa_19.z
	vec4 32 ssa_23 = vec4 ssa_20, ssa_21, ssa_22, ssa_22
	vec1 32 ssa_24 = deref_var &image@0 (uniform image2DArray) 
	intrinsic image_deref_store (ssa_24, ssa_23, ssa_0, ssa_17, ssa_2) (0) /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 16
Compute Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

@compute_lds = external addrspace(3) global [0 x i8], align 65536

define amdgpu_cs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, <3 x i32> %7) #0 {
main_body:
  %8 = ptrtoint float addrspace(6)* %2 to i32
  %9 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %8, i32 0
  %10 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 0, i32 0) #1
  %11 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 4, i32 0) #1
  %12 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 8, i32 0) #1
  %13 = shl i32 %4, 3
  %14 = shl i32 %5, 3
  %15 = extractelement <3 x i32> %7, i32 0
  %16 = add i32 %13, %15
  %17 = extractelement <3 x i32> %7, i32 1
  %18 = add i32 %14, %17
  %19 = extractelement <3 x i32> %7, i32 2
  %20 = add i32 %19, %6
  %21 = bitcast float %10 to i32
  %22 = add i32 %16, %21
  %23 = bitcast float %11 to i32
  %24 = add i32 %18, %23
  %25 = bitcast float %12 to i32
  %26 = add i32 %20, %25
  %27 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 31, !amdgpu.uniform !0
  %28 = load <8 x i32>, <8 x i32> addrspace(6)* %27, align 32, !invariant.load !0
  %29 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.load.2darray.v4f32.i32(i32 15, i32 %22, i32 %24, i32 %26, <8 x i32> %28, i32 0, i32 0) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 16, i32 0) #1
  %31 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 20, i32 0) #1
  %32 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %9, i32 24, i32 0) #1
  %33 = bitcast float %30 to i32
  %34 = add i32 %16, %33
  %35 = bitcast float %31 to i32
  %36 = add i32 %18, %35
  %37 = bitcast float %32 to i32
  %38 = add i32 %20, %37
  %39 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 30, !amdgpu.uniform !0
  %40 = load <8 x i32>, <8 x i32> addrspace(6)* %39, align 32, !invariant.load !0
  %41 = extractelement <8 x i32> %40, i32 6
  %42 = and i32 %41, -2097153
  %43 = insertelement <8 x i32> %40, i32 %42, i32 6
  call void @llvm.amdgcn.image.store.2darray.v4f32.i32(<4 x float> %29, i32 15, i32 %34, i32 %36, i32 %38, <8 x i32> %43, i32 0, i32 0) #4
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.load.2darray.v4f32.i32(i32 immarg, i32, i32, i32, <8 x i32>, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind writeonly
declare void @llvm.amdgcn.image.store.2darray.v4f32.i32(<4 x float>, i32 immarg, i32, i32, i32, <8 x i32>, i32 immarg, i32 immarg) #3

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="64,64" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind writeonly }
attributes #4 = { nounwind }

!0 = !{}

SHADER KEY

Compute Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 s0, s2                                                            ; BE800302
	s_mov_b32 s20, s3                                                           ; BE940303
	s_mov_b32 s3, 0x31016fac                                                    ; BE8303FF 31016FAC
	s_mov_b32 s2, 32                                                            ; BE8203A0
	s_mov_b32 s1, 0x8000                                                        ; BE8103FF 00008000
	s_movk_i32 s21, 0x8000                                                      ; B0158000
	v_lshl_add_u32 v4, s4, 3, v0                                                ; D7460004 04010604
	v_lshl_add_u32 v5, s5, 3, v1                                                ; D7460005 04050605
	v_add_nc_u32_e32 v6, s6, v2                                                 ; 4A0C0406
	s_buffer_load_dwordx2 s[16:17], s[0:3], 0x0                                 ; F4240400 FA000000
	s_buffer_load_dword s7, s[0:3], 0x8                                         ; F42001C0 FA000008
	s_load_dwordx8 s[8:15], s[20:21], 0x3e0                                     ; F40C020A FA0003E0
	s_buffer_load_dwordx2 s[18:19], s[0:3], 0x10                                ; F4240480 FA000010
	s_waitcnt lgkmcnt(0)                                                        ; BF8CC07F
	v_add_nc_u32_e32 v0, s16, v4                                                ; 4A000810
	v_add_nc_u32_e32 v1, s17, v5                                                ; 4A020A11
	v_add_nc_u32_e32 v2, s7, v6                                                 ; 4A040C07
	v_add_nc_u32_e32 v4, s18, v4                                                ; 4A080812
	v_add_nc_u32_e32 v5, s19, v5                                                ; 4A0A0A13
	image_load v[0:3], v[0:2], s[8:15] dmask:0xf dim:SQ_RSRC_IMG_2D_ARRAY unorm ; F0001F28 00020000
	v_nop                                                                       ; 7E000000
	s_buffer_load_dword s8, s[0:3], 0x18                                        ; F4200200 FA000018
	s_load_dwordx8 s[0:7], s[20:21], 0x3c0                                      ; F40C000A FA0003C0
	s_waitcnt lgkmcnt(0)                                                        ; BF8CC07F
	v_add_nc_u32_e32 v6, s8, v6                                                 ; 4A0C0C08
	s_bitset0_b32 s6, 21                                                        ; BE861B95
	s_waitcnt vmcnt(0)                                                          ; BF8C3F70
	image_store v[0:3], v[4:6], s[0:7] dmask:0xf dim:SQ_RSRC_IMG_2D_ARRAY unorm ; F0201F28 00000004
	s_endpgm                                                                    ; BF810000

*** SHADER STATS ***
SGPRS: 24
VGPRS: 8
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 164 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_FRAGMENT
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D sampler (0, 0, 0)
decl_var shader_in INTERP_MODE_NOPERSPECTIVE vec4 in_0 (VARYING_SLOT_VAR0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (FRAG_RESULT_DATA0.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (3) /* interp_mode=3 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* in_0 */
	vec1 32 ssa_3 = f2i32 ssa_2.x
	vec1 32 ssa_4 = f2i32 ssa_2.y
	vec1 32 ssa_5 = deref_var &sampler (uniform sampler2D) 
	vec2 32 ssa_6 = vec2 ssa_3, ssa_4
	vec4 32 ssa_7 = txf ssa_5 (texture_deref), ssa_5 (sampler_deref), ssa_6 (coord), ssa_1 (lod)
	vec1 32 ssa_8 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_8, ssa_7) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 17
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %11 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #3
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #3
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #3
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #3
  %29 = fptosi float %26 to i32
  %30 = fptosi float %28 to i32
  %31 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %32 = load <8 x i32>, <8 x i32> addrspace(6)* %31, align 32, !invariant.load !0
  %33 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.load.2d.v4f32.i32(i32 15, i32 %29, i32 %30, <8 x i32> %32, i32 0, i32 0) #3
  %34 = extractelement <4 x float> %33, i32 0
  %35 = extractelement <4 x float> %33, i32 1
  %36 = extractelement <4 x float> %33, i32 2
  %37 = extractelement <4 x float> %33, i32 3
  %38 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %39 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %38, float %34, 5
  %40 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %39, float %35, 6
  %41 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %40, float %36, 7
  %42 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %41, float %37, 8
  %43 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %42, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %43
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.load.2d.v4f32.i32(i32 immarg, i32, i32, <8 x i32>, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
inputs: 2
outputs: 2
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_FLAT vec4 in_0 (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_FLAT vec4 in_1 (VERT_ATTRIB_GENERIC1.xyzw, 4, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_1 (VARYING_SLOT_VAR0.xyzw, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &in_0 (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &in_1 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_4, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_5 = deref_var &out_1 (shader_out vec4) 
	intrinsic store_deref (ssa_5, ssa_3) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 18
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, i32 inreg %10, i32 inreg %11, float inreg %12, float inreg %13, float inreg %14, float inreg %15, float inreg %16, float inreg %17, float inreg %18, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %31 = and i32 %3, 251658240
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %33 = lshr i32 %2, 12
  %34 = and i32 %33, 511
  %35 = lshr i32 %2, 10
  %36 = and i32 %35, 2093056
  %37 = or i32 %36, %34
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %37) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %38 = lshr i32 %3, 8
  %39 = and i32 %38, 255
  %40 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %41 = icmp ult i32 %40, %39
  br i1 %41, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %42 = bitcast i32 %20 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %42, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %43 = and i32 %3, 255
  %44 = icmp ult i32 %40, %43
  br i1 %44, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %45 = icmp ult i32 %25, 2
  %46 = icmp ne i32 %25, 1
  %.v.v = select i1 %45, i32 %10, i32 %11
  %.v = shl i32 %.v.v, 16
  %47 = ashr exact i32 %.v, 16
  %.v2 = select i1 %46, i32 %10, i32 %11
  %48 = ashr i32 %.v2, 16
  %49 = sitofp i32 %47 to float
  %50 = sitofp i32 %48 to float
  %51 = select nsz arcp contract i1 %45, float %13, float %15
  %52 = select nsz arcp contract i1 %46, float %14, float %16
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %49, float %50, float %12, float 1.000000e+00, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %51, float %52, float %17, float %18, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }

!0 = !{i32 0, i32 32}

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                                               ; BEFE03C1
	s_and_b32 s0, s3, 0xf000000                                                         ; 8700FF03 0F000000
	s_cmp_lg_u32 s0, 0                                                                  ; BF078000
	s_cbranch_scc1 BB0_2                                                                ; BF850000
	s_lshr_b32 s0, s2, 10                                                               ; 90008A02
	s_bfe_u32 s1, s2, 0x9000c                                                           ; 9381FF02 0009000C
	s_and_b32 s0, s0, 0x1ff000                                                          ; 8700FF00 001FF000
	s_or_b32 m0, s0, s1                                                                 ; 887C0100
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                                                 ; BF900009
BB0_2:
	s_bfe_u32 s0, s3, 0x80008                                                           ; 9380FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                                                    ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_4                                                               ; BF880000
BB0_3:
	exp prim v0, off, off, off done                                                     ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                                                 ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s0                                                       ; 887E007E
	s_and_b32 s0, s3, 0xff                                                              ; 8700FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                                                     ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                                                       ; BE803C6A
	s_cbranch_execz BB0_6                                                               ; BF880000
BB0_5:
	v_mov_b32_e32 v0, s10                                                               ; 7E00020A
	v_cmp_gt_u32_e32 vcc_lo, 2, v5                                                      ; 7D880A82
	v_cmp_ne_u32_e64 s30, 1, v5                                                         ; D4C5001E 00020A81
	v_mov_b32_e32 v2, 1.0                                                               ; 7E0402F2
	v_mov_b32_e32 v3, s12                                                               ; 7E06020C
	v_cndmask_b32_e32 v1, s11, v0, vcc_lo                                               ; 0202000B
	v_cndmask_b32_e64 v0, s11, v0, s30                                                  ; D5010000 007A000B
	v_cvt_f32_i32_sdwa v1, sext(v1) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_0 ; 7E020AF9 000C0601
	v_cvt_f32_i32_sdwa v0, sext(v0) dst_sel:DWORD dst_unused:UNUSED_PAD src0_sel:WORD_1 ; 7E000AF9 000D0600
	exp pos0 v1, v0, v3, v2 done vm                                                     ; F80018CF 02030001
	s_waitcnt expcnt(0)                                                                 ; BF8CFF0F
	v_mov_b32_e32 v0, s13                                                               ; 7E00020D
	v_mov_b32_e32 v1, s14                                                               ; 7E02020E
	v_mov_b32_e32 v2, s17                                                               ; 7E040211
	v_mov_b32_e32 v3, s18                                                               ; 7E060212
	v_cndmask_b32_e32 v0, s15, v0, vcc_lo                                               ; 0200000F
	v_cndmask_b32_e64 v1, s16, v1, s30                                                  ; D5010001 007A0210
	exp param0 v0, v1, v2, v3                                                           ; F800020F 03020100
BB0_6:
	s_endpgm                                                                            ; BF810000

*** SHADER STATS ***
SGPRS: 40
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 216 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 7
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 m0, s5                                                      ; BEFC0305
	s_mov_b32 s0, s3                                                      ; BE800303
	s_movk_i32 s1, 0x8000                                                 ; B0018000
	v_interp_p1_f32_e32 v0, v8, attr0.x                                   ; C8000008
	v_interp_p1_f32_e32 v3, v8, attr0.y                                   ; C80C0108
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                 ; F40C0200 FA000400
	v_interp_p2_f32_e32 v0, v9, attr0.x                                   ; C8010009
	v_interp_p2_f32_e32 v3, v9, attr0.y                                   ; C80D0109
	v_cvt_i32_f32_e32 v0, v0                                              ; 7E001100
	v_cvt_i32_f32_e32 v1, v3                                              ; 7E021103
	s_waitcnt lgkmcnt(0)                                                  ; BF8CC07F
	image_load v[0:3], v[0:1], s[8:15] dmask:0xf dim:SQ_RSRC_IMG_2D unorm ; F0001F08 00020000
	s_waitcnt vmcnt(0)                                                    ; BF8C3F70
Shader epilog disassembly:
ps_epilog:
BB0_0:
	v_cvt_pkrtz_f16_f32_e32 v2, v2, v3    ; 5E040702
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	exp mrt0 v0, v0, v2, v2 done compr vm ; F8001C0F 00000200
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0020
*** SHADER STATS ***
SGPRS: 16
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 80 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_FRAGMENT
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D sampler (0, 0, 0)
decl_var shader_in INTERP_MODE_NOPERSPECTIVE vec4 in_0 (VARYING_SLOT_VAR0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (FRAG_RESULT_DATA0.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (3) /* interp_mode=3 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* in_0 */
	vec1 32 ssa_3 = deref_var &sampler (uniform sampler2D) 
	vec2 32 ssa_4 = vec2 ssa_2.x, ssa_2.y
	vec4 32 ssa_5 = txl ssa_3 (texture_deref), ssa_3 (sampler_deref), ssa_4 (coord), ssa_1 (lod)
	vec1 32 ssa_6 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_6, ssa_5) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 19
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %11 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #3
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #3
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #3
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #3
  %29 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %30 = load <8 x i32>, <8 x i32> addrspace(6)* %29, align 32, !invariant.load !0
  %31 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %32 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %31, i32 67, !amdgpu.uniform !0
  %33 = load <4 x i32>, <4 x i32> addrspace(6)* %32, align 16, !invariant.load !0
  %34 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.lz.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %30, <4 x i32> %33, i1 false, i32 0, i32 0) #3
  %35 = extractelement <4 x float> %34, i32 0
  %36 = extractelement <4 x float> %34, i32 1
  %37 = extractelement <4 x float> %34, i32 2
  %38 = extractelement <4 x float> %34, i32 3
  %39 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %40 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %39, float %35, 5
  %41 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %40, float %36, 6
  %42 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %41, float %37, 7
  %43 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %42, float %38, 8
  %44 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %43, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %44
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.lz.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone }

!0 = !{}

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 7
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 s0, s3                                                             ; BE800303
	s_movk_i32 s1, 0x8000                                                        ; B0018000
	s_mov_b32 m0, s5                                                             ; BEFC0305
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                        ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                         ; F4080000 FA000430
	v_interp_p1_f32_e32 v3, v8, attr0.x                                          ; C80C0008
	v_interp_p1_f32_e32 v4, v8, attr0.y                                          ; C8100108
	v_interp_p2_f32_e32 v3, v9, attr0.x                                          ; C80D0009
	v_interp_p2_f32_e32 v4, v9, attr0.y                                          ; C8110109
	s_waitcnt lgkmcnt(0)                                                         ; BF8CC07F
	image_sample_lz v[0:3], v[3:4], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F09C0F08 00020003
	s_waitcnt vmcnt(0)                                                           ; BF8C3F70
Shader epilog disassembly:
ps_epilog:
BB0_0:
	v_cvt_pkrtz_f16_f32_e32 v2, v2, v3    ; 5E040702
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	exp mrt0 v0, v0, v2, v2 done compr vm ; F8001C0F 00000200
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0020
*** SHADER STATS ***
SGPRS: 16
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 80 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


RecordSteamInterfaceCreation (PID 58592): SteamUtils007 / Utils
shader: MESA_SHADER_VERTEX
name: GLSL15
inputs: 4
outputs: 3
uniforms: 6
shared: 0
decl_var uniform INTERP_MODE_NONE mat4 ViewProjMatrix (0, 0, 0)
decl_var uniform INTERP_MODE_NONE float CameraZPos (1, 16, 0)
decl_var uniform INTERP_MODE_NONE float fFocusFactor (2, 17, 0)
decl_var uniform INTERP_MODE_NONE float fFocusRatio (3, 18, 0)
decl_var uniform INTERP_MODE_NONE float fFogDensity (4, 19, 0)
decl_var uniform INTERP_MODE_NONE float fFogFalloff (5, 20, 0)
decl_var uniform INTERP_MODE_NONE float fFogTone (6, 21, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color1 (VERT_ATTRIB_GENERIC3.xyzw, 8, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 12, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_add (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_add@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_add@1 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.w, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul@2 (VARYING_SLOT_VAR1.x, 8, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul@3 (VARYING_SLOT_VAR1.y, 8, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR1.z, 8, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv@4 (VARYING_SLOT_VAR1.w, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &color1 (shader_in vec4) 
	vec4 32 ssa_5 = intrinsic load_deref (ssa_4) (0) /* access=0 */
	vec1 32 ssa_6 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_7 = intrinsic load_deref (ssa_6) (0) /* access=0 */
	vec1 32 ssa_8 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_9 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_10 = load_const (0x3fb8aa3b /* 1.442695 */)
	vec1 32 ssa_11 = load_const (0x40800000 /* 4.000000 */)
	vec1 32 ssa_12 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_13 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_14 = load_const (0x3ecccccd /* 0.400000 */)
	vec1 32 ssa_15 = load_const (0x40a00000 /* 5.000000 */)
	vec4 32 ssa_16 = intrinsic load_ubo (ssa_8, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_17 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_18 = intrinsic load_ubo (ssa_8, ssa_17) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_19 = fmul ssa_18.x, ssa_1.y
	vec1 32 ssa_20 = fmul ssa_18.y, ssa_1.y
	vec1 32 ssa_21 = fmul ssa_18.z, ssa_1.y
	vec1 32 ssa_22 = fmul ssa_18.w, ssa_1.y
	vec1 32 ssa_23 = ffma ssa_16.x, ssa_1.x, ssa_19
	vec1 32 ssa_24 = ffma ssa_16.y, ssa_1.x, ssa_20
	vec1 32 ssa_25 = ffma ssa_16.z, ssa_1.x, ssa_21
	vec1 32 ssa_26 = ffma ssa_16.w, ssa_1.x, ssa_22
	vec1 32 ssa_27 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_28 = intrinsic load_ubo (ssa_8, ssa_27) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_29 = ffma ssa_28.x, ssa_1.z, ssa_23
	vec1 32 ssa_30 = ffma ssa_28.y, ssa_1.z, ssa_24
	vec1 32 ssa_31 = ffma ssa_28.z, ssa_1.z, ssa_25
	vec1 32 ssa_32 = ffma ssa_28.w, ssa_1.z, ssa_26
	vec1 32 ssa_33 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_34 = intrinsic load_ubo (ssa_8, ssa_33) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_35 = ffma ssa_34.x, ssa_1.w, ssa_29
	vec1 32 ssa_36 = ffma ssa_34.y, ssa_1.w, ssa_30
	vec1 32 ssa_37 = ffma ssa_34.z, ssa_1.w, ssa_31
	vec1 32 ssa_38 = ffma ssa_34.w, ssa_1.w, ssa_32
	vec1 32 ssa_39 = fmax ssa_8, ssa_1.z
	vec1 32 ssa_40 = load_const (0x0000004c /* 0.000000 */)
	vec1 32 ssa_41 = intrinsic load_ubo (ssa_8, ssa_40) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_42 = fmul ssa_39, ssa_41
	vec1 32 ssa_43 = load_const (0x00000050 /* 0.000000 */)
	vec1 32 ssa_44 = intrinsic load_ubo (ssa_8, ssa_43) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_45 = fpow ssa_42, ssa_44
	vec1 32 ssa_46 = fmul ssa_45, ssa_10
	vec1 32 ssa_47 = fmul ssa_46, ssa_5.y
	vec1 32 ssa_48 = fneg ssa_47
	vec1 32 ssa_49 = fexp2 ssa_48
	vec1 32 ssa_50 = fneg ssa_49
	vec1 32 ssa_51 = fadd ssa_9, ssa_50
	vec1 32 ssa_52 = fmul ssa_11, ssa_5.z
	vec1 32 ssa_53 = load_const (0x00000040 /* 0.000000 */)
	vec1 32 ssa_54 = intrinsic load_ubo (ssa_8, ssa_53) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_55 = fneg ssa_54
	vec1 32 ssa_56 = fadd ssa_1.z, ssa_12
	vec1 32 ssa_57 = fadd ssa_56, ssa_55
	vec1 32 ssa_58 = ffma ssa_11, ssa_5.z, ssa_57
	vec1 32 ssa_59 = frcp ssa_54
	vec1 32 ssa_60 = fmul ssa_58, ssa_59
	vec1 32 ssa_61 = fabs ssa_60
	vec1 32 ssa_62 = flog2 ssa_61
	vec1 32 ssa_63 = fmul ssa_62, ssa_52
	vec1 32 ssa_64 = fabs ssa_63
	vec1 32 ssa_65 = fsqrt ssa_64
	vec1 32 ssa_66 = flt32 ssa_63, ssa_8
	vec1 32 ssa_67 = load_const (0x00000048 /* 0.000000 */)
	vec1 32 ssa_68 = intrinsic load_ubo (ssa_8, ssa_67) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_69 = b32csel ssa_66, ssa_68, ssa_9
	vec1 32 ssa_70 = load_const (0x00000044 /* 0.000000 */)
	vec1 32 ssa_71 = intrinsic load_ubo (ssa_8, ssa_70) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_72 = fmul ssa_65, ssa_71
	vec1 32 ssa_73 = fmul ssa_72, ssa_69
	vec1 32 ssa_74 = fmul ssa_13, ssa_5.x
	vec1 32 ssa_75 = ffma ssa_13, ssa_5.x, ssa_12
	vec1 32 ssa_76 = fge32 ssa_75, ssa_8
	vec1 32 ssa_77 = fneg ssa_74
	vec1 32 ssa_78 = fadd ssa_13, ssa_77
	vec1 32 ssa_79 = b32csel ssa_76, ssa_78, ssa_74
	vec1 32 ssa_80 = fmax ssa_8, ssa_75
	vec1 32 ssa_81 = fmul ssa_79, ssa_49
	vec1 32 ssa_82 = fmul ssa_3.x, ssa_81
	vec1 32 ssa_83 = fmul ssa_5.w, ssa_81
	vec1 32 ssa_84 = load_const (0x00000054 /* 0.000000 */)
	vec1 32 ssa_85 = intrinsic load_ubo (ssa_8, ssa_84) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_86 = fmul ssa_51, ssa_85
	vec1 32 ssa_87 = ffma ssa_80, ssa_49, ssa_86
	vec1 32 ssa_88 = fmul ssa_5.w, ssa_87
	vec1 32 ssa_89 = fmax ssa_73, ssa_8
	vec1 32 ssa_90 = fmin ssa_89, ssa_15
	vec1 32 ssa_91 = fmul ssa_14, ssa_90
	vec1 32 ssa_92 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_93 = vec4 ssa_35, ssa_36, ssa_37, ssa_38
	intrinsic store_deref (ssa_92, ssa_93) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_94 = deref_var &v_add (shader_out float) 
	intrinsic store_deref (ssa_94, ssa_87) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_95 = deref_var &v_add@0 (shader_out float) 
	intrinsic store_deref (ssa_95, ssa_88) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_96 = deref_var &v_add@1 (shader_out float) 
	intrinsic store_deref (ssa_96, ssa_91) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_97 = deref_var &v_mul (shader_out float) 
	intrinsic store_deref (ssa_97, ssa_82) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_98 = deref_var &v_mul@2 (shader_out float) 
	intrinsic store_deref (ssa_98, ssa_83) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_99 = deref_var &v_mul@3 (shader_out float) 
	vec1 32 ssa_100 = mov ssa_3.w
	intrinsic store_deref (ssa_99, ssa_100) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_101 = deref_var &v_uv (shader_out float) 
	vec1 32 ssa_102 = mov ssa_7.x
	intrinsic store_deref (ssa_101, ssa_102) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_103 = deref_var &v_uv@4 (shader_out float) 
	vec1 32 ssa_104 = mov ssa_7.y
	intrinsic store_deref (ssa_103, ssa_104) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 20
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, <4 x i32> inreg %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34, i32 %35, i32 %36) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %37 = and i32 %3, 251658240
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %39 = lshr i32 %2, 12
  %40 = and i32 %39, 511
  %41 = lshr i32 %2, 10
  %42 = and i32 %41, 2093056
  %43 = or i32 %42, %40
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %43) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %44 = lshr i32 %3, 8
  %45 = and i32 %44, 255
  %46 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %47 = icmp ult i32 %46, %45
  br i1 %47, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %48 = bitcast i32 %24 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %48, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %49 = and i32 %3, 255
  %50 = icmp ult i32 %46, %49
  br i1 %50, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %51 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %33, i32 0, i32 0, i32 0) #3
  %52 = extractelement <4 x float> %51, i32 0
  %53 = extractelement <4 x float> %51, i32 1
  %54 = extractelement <4 x float> %51, i32 2
  %55 = extractelement <4 x float> %51, i32 3
  %56 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %34, i32 0, i32 0, i32 0) #3
  %57 = extractelement <4 x float> %56, i32 0
  %58 = extractelement <4 x float> %56, i32 3
  %59 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %22, i32 %35, i32 0, i32 0, i32 0) #3
  %60 = extractelement <4 x float> %59, i32 0
  %61 = extractelement <4 x float> %59, i32 1
  %62 = extractelement <4 x float> %59, i32 2
  %63 = extractelement <4 x float> %59, i32 3
  %64 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %23, i32 %36, i32 0, i32 0, i32 0) #3
  %65 = extractelement <2 x float> %64, i32 0
  %66 = extractelement <2 x float> %64, i32 1
  %67 = ptrtoint float addrspace(6)* %10 to i32
  %68 = insertelement <4 x i32> <i32 undef, i32 32768, i32 96, i32 822177708>, i32 %67, i32 0
  %69 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 0, i32 0) #3
  %70 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 4, i32 0) #3
  %71 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 8, i32 0) #3
  %72 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 12, i32 0) #3
  %73 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 16, i32 0) #3
  %74 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 20, i32 0) #3
  %75 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 24, i32 0) #3
  %76 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 28, i32 0) #3
  %77 = fmul nsz arcp contract float %73, %53
  %78 = fmul nsz arcp contract float %74, %53
  %79 = fmul nsz arcp contract float %75, %53
  %80 = fmul nsz arcp contract float %76, %53
  %81 = call nsz arcp contract float @llvm.fma.f32(float %69, float %52, float %77) #3
  %82 = call nsz arcp contract float @llvm.fma.f32(float %70, float %52, float %78) #3
  %83 = call nsz arcp contract float @llvm.fma.f32(float %71, float %52, float %79) #3
  %84 = call nsz arcp contract float @llvm.fma.f32(float %72, float %52, float %80) #3
  %85 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 32, i32 0) #3
  %86 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 36, i32 0) #3
  %87 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 40, i32 0) #3
  %88 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 44, i32 0) #3
  %89 = call nsz arcp contract float @llvm.fma.f32(float %85, float %54, float %81) #3
  %90 = call nsz arcp contract float @llvm.fma.f32(float %86, float %54, float %82) #3
  %91 = call nsz arcp contract float @llvm.fma.f32(float %87, float %54, float %83) #3
  %92 = call nsz arcp contract float @llvm.fma.f32(float %88, float %54, float %84) #3
  %93 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 48, i32 0) #3
  %94 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 52, i32 0) #3
  %95 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 56, i32 0) #3
  %96 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 60, i32 0) #3
  %97 = call nsz arcp contract float @llvm.fma.f32(float %93, float %55, float %89) #3
  %98 = call nsz arcp contract float @llvm.fma.f32(float %94, float %55, float %90) #3
  %99 = call nsz arcp contract float @llvm.fma.f32(float %95, float %55, float %91) #3
  %100 = call nsz arcp contract float @llvm.fma.f32(float %96, float %55, float %92) #3
  %101 = call nsz arcp contract float @llvm.maxnum.f32(float %54, float 0.000000e+00) #3
  %102 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 76, i32 0) #3
  %103 = fmul nsz arcp contract float %101, %102
  %104 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 80, i32 0) #3
  %105 = call nsz arcp contract float @llvm.pow.f32(float %103, float %104) #3
  %106 = fmul nsz arcp contract float %105, 0xBFF7154760000000
  %107 = fmul nsz arcp contract float %61, %106
  %108 = call nsz arcp contract float @llvm.exp2.f32(float %107) #3
  %109 = fsub nsz arcp contract float 1.000000e+00, %108
  %110 = fmul nsz arcp contract float %62, 4.000000e+00
  %111 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 64, i32 0) #3
  %112 = fadd nsz arcp contract float %54, -1.000000e+00
  %113 = fsub nsz arcp contract float %112, %111
  %114 = call nsz arcp contract float @llvm.fma.f32(float %62, float 4.000000e+00, float %113) #3
  %115 = call nsz arcp contract float @llvm.amdgcn.rcp.f32(float %111) #3
  %116 = fmul nsz arcp contract float %114, %115
  %117 = call nsz arcp contract float @llvm.fabs.f32(float %116) #3
  %118 = call nsz arcp contract float @llvm.log2.f32(float %117) #3
  %119 = fmul nsz arcp contract float %118, %110
  %120 = call nsz arcp contract float @llvm.fabs.f32(float %119) #3
  %121 = call nsz arcp contract float @llvm.sqrt.f32(float %120) #3
  %122 = fcmp nsz arcp contract olt float %119, 0.000000e+00
  %123 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 72, i32 0) #3
  %124 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 68, i32 0) #3
  %125 = fmul nsz arcp contract float %121, %124
  %126 = select i1 %122, float %123, float 1.000000e+00
  %127 = fmul nsz arcp contract float %125, %126
  %128 = fmul nsz arcp contract float %60, 2.000000e+00
  %129 = call nsz arcp contract float @llvm.fma.f32(float %60, float 2.000000e+00, float -1.000000e+00) #3
  %130 = fcmp nsz arcp contract oge float %129, 0.000000e+00
  %131 = fsub nsz arcp contract float 2.000000e+00, %128
  %.v = select i1 %130, float %131, float %128
  %132 = call nsz arcp contract float @llvm.maxnum.f32(float %129, float 0.000000e+00) #3
  %133 = fmul nsz arcp contract float %.v, %108
  %134 = fmul nsz arcp contract float %57, %133
  %135 = fmul nsz arcp contract float %63, %133
  %136 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %68, i32 84, i32 0) #3
  %137 = fmul nsz arcp contract float %109, %136
  %138 = call nsz arcp contract float @llvm.fma.f32(float %132, float %108, float %137) #3
  %139 = fmul nsz arcp contract float %63, %138
  %140 = call nsz arcp contract float @llvm.maxnum.f32(float %127, float 0.000000e+00) #3
  %141 = call nsz arcp contract float @llvm.minnum.f32(float %140, float 5.000000e+00) #3
  %142 = fmul nsz arcp contract float %141, 0x3FD99999A0000000
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %97, float %98, float %99, float %100, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %138, float %139, float %142, float %134, i1 false, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 33, i32 15, float %135, float %58, float %65, float %66, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.maxnum.f32(float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.pow.f32(float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.exp2.f32(float) #6

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #7

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fabs.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.log2.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.sqrt.f32(float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.minnum.f32(float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }
attributes #7 = { nounwind readnone speculatable }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL15
inputs: 2
outputs: 1
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float fLodBias (7, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (8, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add@1 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR1.z, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv@2 (VARYING_SLOT_VAR1.w, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul@3 (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul@4 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_add */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_add */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_add */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_mul */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 2) /* base=1 */ /* component=2 */	/* v_uv */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 3) /* base=1 */ /* component=3 */	/* v_uv */
	vec1 32 ssa_8 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* v_mul */
	vec1 32 ssa_9 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* v_mul */
	vec1 32 ssa_10 = undefined
	vec1 32 ssa_11 = load_const (0x40200000 /* 2.500000 */)
	vec1 32 ssa_12 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_13 = vec2 ssa_6, ssa_7
	vec1 32 ssa_14 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_15 = ffma ssa_11, ssa_4, ssa_14
	vec4 32 ssa_16 = txb ssa_12 (texture_deref), ssa_12 (sampler_deref), ssa_13 (coord), ssa_15 (bias)
	vec1 32 ssa_17 = ffma ssa_16.x, ssa_5, ssa_2
	vec1 32 ssa_18 = ffma ssa_16.y, ssa_8, ssa_3
	vec1 32 ssa_19 = ffma ssa_16.z, ssa_10, ssa_4
	vec1 32 ssa_20 = fmul ssa_16.w, ssa_9
	vec1 32 ssa_21 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_22 = vec4 ssa_17, ssa_18, ssa_19, ssa_20
	intrinsic store_deref (ssa_21, ssa_22) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 21
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #2
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #2
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #2
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 1, i32 %5) #2
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 2, i32 1, i32 %5) #2
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 1, i32 %5) #2
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 3, i32 1, i32 %5) #2
  %37 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #2
  %38 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %37, float %24, i32 0, i32 1, i32 %5) #2
  %39 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #2
  %40 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %39, float %24, i32 1, i32 1, i32 %5) #2
  %41 = ptrtoint float addrspace(6)* %2 to i32
  %42 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %41, i32 0
  %43 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %42, i32 0, i32 0) #2
  %44 = call nsz arcp contract float @llvm.fma.f32(float %30, float 2.500000e+00, float %43) #2
  %45 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %46 = load <8 x i32>, <8 x i32> addrspace(6)* %45, align 32, !invariant.load !0
  %47 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %48 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %47, i32 67, !amdgpu.uniform !0
  %49 = load <4 x i32>, <4 x i32> addrspace(6)* %48, align 16, !invariant.load !0
  %50 = call <3 x float> @llvm.amdgcn.image.sample.b.2d.v3f32.f32.f32(i32 11, float %44, float %34, float %36, <8 x i32> %46, <4 x i32> %49, i1 false, i32 0, i32 0)
  %51 = extractelement <3 x float> %50, i32 0
  %52 = call nsz arcp contract float @llvm.fma.f32(float %51, float %32, float %26) #2
  %53 = extractelement <3 x float> %50, i32 1
  %54 = call nsz arcp contract float @llvm.fma.f32(float %53, float %38, float %28) #2
  %55 = extractelement <3 x float> %50, i32 2
  %56 = fmul nsz arcp contract float %55, %40
  %57 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %58 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %57, float %52, 5
  %59 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %58, float %54, 6
  %60 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %59, float 0x7FF8000000000000, 7
  %61 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %60, float %56, 8
  %62 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %61, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %62
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.b.2d.v4f32.f32.f32(i32 immarg, float, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #4

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.amdgcn.image.sample.b.2d.v3f32.f32.f32(i32 immarg, float, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #4

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readonly }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL18
inputs: 3
outputs: 2
uniforms: 4
shared: 0
decl_var uniform INTERP_MODE_NONE mat4 ViewProjMatrix (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 8, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_color (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_color@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_5 = intrinsic load_deref (ssa_4) (0) /* access=0 */
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_7 = load_const (0x3a83126f /* 0.001000 */)
	vec4 32 ssa_8 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_9 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_10 = intrinsic load_ubo (ssa_6, ssa_9) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_11 = fmul ssa_10.x, ssa_1.y
	vec1 32 ssa_12 = fmul ssa_10.y, ssa_1.y
	vec1 32 ssa_13 = fmul ssa_10.z, ssa_1.y
	vec1 32 ssa_14 = fmul ssa_10.w, ssa_1.y
	vec1 32 ssa_15 = ffma ssa_8.x, ssa_1.x, ssa_11
	vec1 32 ssa_16 = ffma ssa_8.y, ssa_1.x, ssa_12
	vec1 32 ssa_17 = ffma ssa_8.z, ssa_1.x, ssa_13
	vec1 32 ssa_18 = ffma ssa_8.w, ssa_1.x, ssa_14
	vec1 32 ssa_19 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_20 = intrinsic load_ubo (ssa_6, ssa_19) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_21 = ffma ssa_20.x, ssa_1.z, ssa_15
	vec1 32 ssa_22 = ffma ssa_20.y, ssa_1.z, ssa_16
	vec1 32 ssa_23 = ffma ssa_20.z, ssa_1.z, ssa_17
	vec1 32 ssa_24 = ffma ssa_20.w, ssa_1.z, ssa_18
	vec1 32 ssa_25 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_26 = intrinsic load_ubo (ssa_6, ssa_25) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_27 = ffma ssa_26.x, ssa_1.w, ssa_21
	vec1 32 ssa_28 = ffma ssa_26.y, ssa_1.w, ssa_22
	vec1 32 ssa_29 = ffma ssa_26.w, ssa_1.w, ssa_24
	vec1 32 ssa_30 = fadd ssa_23, ssa_7
	vec1 32 ssa_31 = ffma ssa_26.z, ssa_1.w, ssa_30
	vec1 32 ssa_32 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_33 = vec4 ssa_27, ssa_28, ssa_31, ssa_29
	intrinsic store_deref (ssa_32, ssa_33) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_34 = deref_var &v_color (shader_out float) 
	vec1 32 ssa_35 = mov ssa_3.x
	intrinsic store_deref (ssa_34, ssa_35) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_36 = deref_var &v_color@0 (shader_out float) 
	vec1 32 ssa_37 = mov ssa_3.w
	intrinsic store_deref (ssa_36, ssa_37) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_38 = deref_var &v_uv (shader_out float) 
	vec1 32 ssa_39 = mov ssa_5.x
	intrinsic store_deref (ssa_38, ssa_39) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_40 = deref_var &v_uv@1 (shader_out float) 
	vec1 32 ssa_41 = mov ssa_5.y
	intrinsic store_deref (ssa_40, ssa_41) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 22
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %35 = and i32 %3, 251658240
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %37 = lshr i32 %2, 12
  %38 = and i32 %37, 511
  %39 = lshr i32 %2, 10
  %40 = and i32 %39, 2093056
  %41 = or i32 %40, %38
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %41) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %42 = lshr i32 %3, 8
  %43 = and i32 %42, 255
  %44 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %45 = icmp ult i32 %44, %43
  br i1 %45, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %46 = bitcast i32 %23 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %46, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %47 = and i32 %3, 255
  %48 = icmp ult i32 %44, %47
  br i1 %48, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %49 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %32, i32 0, i32 0, i32 0) #3
  %50 = extractelement <4 x float> %49, i32 0
  %51 = extractelement <4 x float> %49, i32 1
  %52 = extractelement <4 x float> %49, i32 2
  %53 = extractelement <4 x float> %49, i32 3
  %54 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %33, i32 0, i32 0, i32 0) #3
  %55 = extractelement <4 x float> %54, i32 0
  %56 = extractelement <4 x float> %54, i32 3
  %57 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %22, i32 %34, i32 0, i32 0, i32 0) #3
  %58 = extractelement <2 x float> %57, i32 0
  %59 = extractelement <2 x float> %57, i32 1
  %60 = ptrtoint float addrspace(6)* %10 to i32
  %61 = insertelement <4 x i32> <i32 undef, i32 32768, i32 64, i32 822177708>, i32 %60, i32 0
  %62 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 0, i32 0) #3
  %63 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 4, i32 0) #3
  %64 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 8, i32 0) #3
  %65 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 12, i32 0) #3
  %66 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 16, i32 0) #3
  %67 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 20, i32 0) #3
  %68 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 24, i32 0) #3
  %69 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 28, i32 0) #3
  %70 = fmul nsz arcp contract float %66, %51
  %71 = fmul nsz arcp contract float %67, %51
  %72 = fmul nsz arcp contract float %68, %51
  %73 = fmul nsz arcp contract float %69, %51
  %74 = call nsz arcp contract float @llvm.fma.f32(float %62, float %50, float %70) #3
  %75 = call nsz arcp contract float @llvm.fma.f32(float %63, float %50, float %71) #3
  %76 = call nsz arcp contract float @llvm.fma.f32(float %64, float %50, float %72) #3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %65, float %50, float %73) #3
  %78 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 32, i32 0) #3
  %79 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 36, i32 0) #3
  %80 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 40, i32 0) #3
  %81 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 44, i32 0) #3
  %82 = call nsz arcp contract float @llvm.fma.f32(float %78, float %52, float %74) #3
  %83 = call nsz arcp contract float @llvm.fma.f32(float %79, float %52, float %75) #3
  %84 = call nsz arcp contract float @llvm.fma.f32(float %80, float %52, float %76) #3
  %85 = call nsz arcp contract float @llvm.fma.f32(float %81, float %52, float %77) #3
  %86 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 48, i32 0) #3
  %87 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 52, i32 0) #3
  %88 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 56, i32 0) #3
  %89 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 60, i32 0) #3
  %90 = call nsz arcp contract float @llvm.fma.f32(float %86, float %53, float %82) #3
  %91 = call nsz arcp contract float @llvm.fma.f32(float %87, float %53, float %83) #3
  %92 = call nsz arcp contract float @llvm.fma.f32(float %89, float %53, float %85) #3
  %93 = fadd nsz arcp contract float %84, 0x3F50624DE0000000
  %94 = call nsz arcp contract float @llvm.fma.f32(float %88, float %53, float %93) #3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %90, float %91, float %94, float %92, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %55, float %56, float %58, float %59, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL18
inputs: 1
outputs: 1
uniforms: 3
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 iFogColor (1, 0, 0)
decl_var uniform INTERP_MODE_NONE vec4 viewport (2, 4, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (4, 1, 1)
decl_var uniform INTERP_MODE_NONE vec4 gl_FbWposYTransform (0, 8, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv@0 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_color (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_color@1 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_uv */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_uv */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_color */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_color */
	vec1 32 ssa_6 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_7 = vec2 ssa_2, ssa_3
	vec4 32 ssa_8 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_9 = mov ssa_8.w
	vec4 32 ssa_10 = txb ssa_6 (texture_deref), ssa_6 (sampler_deref), ssa_7 (coord), ssa_9 (bias)
	vec1 32 ssa_11 = deref_var &texture1 (uniform sampler2D) 
	vec4 32 ssa_12 = intrinsic load_frag_coord () ()
	vec1 32 ssa_13 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_14 = intrinsic load_ubo (ssa_1, ssa_13) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_15 = ffma ssa_12.y, ssa_14.x, ssa_14.y
	vec1 32 ssa_16 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_17 = intrinsic load_ubo (ssa_1, ssa_16) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_18 = fmul ssa_12.x, ssa_17.x
	vec1 32 ssa_19 = fmul ssa_15, ssa_17.y
	vec2 32 ssa_20 = vec2 ssa_18, ssa_19
	vec4 32 ssa_21 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_20 (coord)
	vec1 32 ssa_22 = fadd ssa_10.x, ssa_21.x
	vec1 32 ssa_23 = fneg ssa_22
	vec1 32 ssa_24 = fadd ssa_4, ssa_23
	vec1 32 ssa_25 = ffma ssa_5, ssa_24, ssa_22
	vec1 32 ssa_26 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_27 = vec4 ssa_25, ssa_1, ssa_1, ssa_10.w
	intrinsic store_deref (ssa_26, ssa_27) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 23
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 2, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 3, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 0, i32 0, i32 %5) #2
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 1, i32 0, i32 %5) #2
  %33 = ptrtoint float addrspace(6)* %2 to i32
  %34 = insertelement <4 x i32> <i32 undef, i32 32768, i32 48, i32 822177708>, i32 %33, i32 0
  %35 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 12, i32 0) #2
  %36 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %37 = load <8 x i32>, <8 x i32> addrspace(6)* %36, align 32, !invariant.load !0
  %38 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %39 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %38, i32 67, !amdgpu.uniform !0
  %40 = load <4 x i32>, <4 x i32> addrspace(6)* %39, align 16, !invariant.load !0
  %41 = call <2 x float> @llvm.amdgcn.image.sample.b.2d.v2f32.f32.f32(i32 9, float %35, float %26, float %28, <8 x i32> %37, <4 x i32> %40, i1 false, i32 0, i32 0)
  %42 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 32, i32 0) #2
  %43 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 36, i32 0) #2
  %44 = call nsz arcp contract float @llvm.fma.f32(float %15, float %42, float %43) #2
  %45 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 16, i32 0) #2
  %46 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 20, i32 0) #2
  %47 = fmul nsz arcp contract float %45, %14
  %48 = fmul nsz arcp contract float %44, %46
  %49 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %50 = load <8 x i32>, <8 x i32> addrspace(6)* %49, align 32, !invariant.load !0
  %51 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %38, i32 71, !amdgpu.uniform !0
  %52 = load <4 x i32>, <4 x i32> addrspace(6)* %51, align 16, !invariant.load !0
  %53 = call float @llvm.amdgcn.image.sample.2d.f32.f32(i32 1, float %47, float %48, <8 x i32> %50, <4 x i32> %52, i1 false, i32 0, i32 0)
  %54 = extractelement <2 x float> %41, i32 0
  %55 = fadd nsz arcp contract float %54, %53
  %56 = fsub nsz arcp contract float %30, %55
  %57 = call nsz arcp contract float @llvm.fma.f32(float %32, float %56, float %55) #2
  %58 = extractelement <2 x float> %41, i32 1
  %59 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %60 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %59, float %57, 5
  %61 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %60, float 0.000000e+00, 6
  %62 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %61, float 0.000000e+00, 7
  %63 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %62, float %58, 8
  %64 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %63, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %64
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.b.2d.v4f32.f32.f32(i32 immarg, float, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.image.sample.b.2d.v2f32.f32.f32(i32 immarg, float, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

; Function Attrs: nounwind readonly
declare float @llvm.amdgcn.image.sample.2d.f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #3

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }
attributes #4 = { nounwind readnone speculatable willreturn }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL21
inputs: 3
outputs: 2
uniforms: 4
shared: 0
decl_var uniform INTERP_MODE_NONE mat4 ViewProjMatrix (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 8, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_5 = intrinsic load_deref (ssa_4) (0) /* access=0 */
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_7 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_8 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_6, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = fmul ssa_9.x, ssa_1.y
	vec1 32 ssa_11 = fmul ssa_9.y, ssa_1.y
	vec1 32 ssa_12 = fmul ssa_9.z, ssa_1.y
	vec1 32 ssa_13 = fmul ssa_9.w, ssa_1.y
	vec1 32 ssa_14 = ffma ssa_7.x, ssa_1.x, ssa_10
	vec1 32 ssa_15 = ffma ssa_7.y, ssa_1.x, ssa_11
	vec1 32 ssa_16 = ffma ssa_7.z, ssa_1.x, ssa_12
	vec1 32 ssa_17 = ffma ssa_7.w, ssa_1.x, ssa_13
	vec1 32 ssa_18 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_19 = intrinsic load_ubo (ssa_6, ssa_18) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_20 = ffma ssa_19.x, ssa_1.z, ssa_14
	vec1 32 ssa_21 = ffma ssa_19.y, ssa_1.z, ssa_15
	vec1 32 ssa_22 = ffma ssa_19.z, ssa_1.z, ssa_16
	vec1 32 ssa_23 = ffma ssa_19.w, ssa_1.z, ssa_17
	vec1 32 ssa_24 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_25 = intrinsic load_ubo (ssa_6, ssa_24) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_26 = ffma ssa_25.x, ssa_1.w, ssa_20
	vec1 32 ssa_27 = ffma ssa_25.y, ssa_1.w, ssa_21
	vec1 32 ssa_28 = ffma ssa_25.z, ssa_1.w, ssa_22
	vec1 32 ssa_29 = ffma ssa_25.w, ssa_1.w, ssa_23
	vec1 32 ssa_30 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_31 = vec4 ssa_26, ssa_27, ssa_28, ssa_29
	intrinsic store_deref (ssa_30, ssa_31) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_32 = deref_var &v_mul (shader_out float) 
	vec1 32 ssa_33 = mov ssa_3.x
	intrinsic store_deref (ssa_32, ssa_33) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_34 = deref_var &v_mul@0 (shader_out float) 
	vec1 32 ssa_35 = mov ssa_3.w
	intrinsic store_deref (ssa_34, ssa_35) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_36 = deref_var &v_uv (shader_out float) 
	vec1 32 ssa_37 = mov ssa_5.x
	intrinsic store_deref (ssa_36, ssa_37) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_38 = deref_var &v_uv@1 (shader_out float) 
	vec1 32 ssa_39 = mov ssa_5.y
	intrinsic store_deref (ssa_38, ssa_39) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 24
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %35 = and i32 %3, 251658240
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %37 = lshr i32 %2, 12
  %38 = and i32 %37, 511
  %39 = lshr i32 %2, 10
  %40 = and i32 %39, 2093056
  %41 = or i32 %40, %38
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %41) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %42 = lshr i32 %3, 8
  %43 = and i32 %42, 255
  %44 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %45 = icmp ult i32 %44, %43
  br i1 %45, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %46 = bitcast i32 %23 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %46, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %47 = and i32 %3, 255
  %48 = icmp ult i32 %44, %47
  br i1 %48, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %49 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %32, i32 0, i32 0, i32 0) #3
  %50 = extractelement <4 x float> %49, i32 0
  %51 = extractelement <4 x float> %49, i32 1
  %52 = extractelement <4 x float> %49, i32 2
  %53 = extractelement <4 x float> %49, i32 3
  %54 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %33, i32 0, i32 0, i32 0) #3
  %55 = extractelement <4 x float> %54, i32 0
  %56 = extractelement <4 x float> %54, i32 3
  %57 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %22, i32 %34, i32 0, i32 0, i32 0) #3
  %58 = extractelement <2 x float> %57, i32 0
  %59 = extractelement <2 x float> %57, i32 1
  %60 = ptrtoint float addrspace(6)* %10 to i32
  %61 = insertelement <4 x i32> <i32 undef, i32 32768, i32 64, i32 822177708>, i32 %60, i32 0
  %62 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 0, i32 0) #3
  %63 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 4, i32 0) #3
  %64 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 8, i32 0) #3
  %65 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 12, i32 0) #3
  %66 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 16, i32 0) #3
  %67 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 20, i32 0) #3
  %68 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 24, i32 0) #3
  %69 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 28, i32 0) #3
  %70 = fmul nsz arcp contract float %66, %51
  %71 = fmul nsz arcp contract float %67, %51
  %72 = fmul nsz arcp contract float %68, %51
  %73 = fmul nsz arcp contract float %69, %51
  %74 = call nsz arcp contract float @llvm.fma.f32(float %62, float %50, float %70) #3
  %75 = call nsz arcp contract float @llvm.fma.f32(float %63, float %50, float %71) #3
  %76 = call nsz arcp contract float @llvm.fma.f32(float %64, float %50, float %72) #3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %65, float %50, float %73) #3
  %78 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 32, i32 0) #3
  %79 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 36, i32 0) #3
  %80 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 40, i32 0) #3
  %81 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 44, i32 0) #3
  %82 = call nsz arcp contract float @llvm.fma.f32(float %78, float %52, float %74) #3
  %83 = call nsz arcp contract float @llvm.fma.f32(float %79, float %52, float %75) #3
  %84 = call nsz arcp contract float @llvm.fma.f32(float %80, float %52, float %76) #3
  %85 = call nsz arcp contract float @llvm.fma.f32(float %81, float %52, float %77) #3
  %86 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 48, i32 0) #3
  %87 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 52, i32 0) #3
  %88 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 56, i32 0) #3
  %89 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 60, i32 0) #3
  %90 = call nsz arcp contract float @llvm.fma.f32(float %86, float %53, float %82) #3
  %91 = call nsz arcp contract float @llvm.fma.f32(float %87, float %53, float %83) #3
  %92 = call nsz arcp contract float @llvm.fma.f32(float %88, float %53, float %84) #3
  %93 = call nsz arcp contract float @llvm.fma.f32(float %89, float %53, float %85) #3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %90, float %91, float %92, float %93, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %55, float %56, float %58, float %59, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL21
inputs: 1
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 viewport (1, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (2, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (3, 1, 1)
decl_var uniform INTERP_MODE_NONE vec4 gl_FbWposYTransform (0, 4, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv@0 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul@1 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_uv */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_uv */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_mul */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_mul */
	vec1 32 ssa_6 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_7 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_8 = load_const (0x42c80000 /* 100.000000 */)
	vec1 32 ssa_9 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_10 = deref_var &texture1 (uniform sampler2D) 
	vec4 32 ssa_11 = intrinsic load_frag_coord () ()
	vec1 32 ssa_12 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_13 = intrinsic load_ubo (ssa_1, ssa_12) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_14 = ffma ssa_11.y, ssa_13.x, ssa_13.y
	vec1 32 ssa_15 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_16 = vec2 ssa_2, ssa_3
	vec4 32 ssa_17 = tex ssa_15 (texture_deref), ssa_15 (sampler_deref), ssa_16 (coord)
	vec1 32 ssa_18 = ffma ssa_17.z, ssa_6, ssa_7
	vec1 32 ssa_19 = ffma ssa_17.w, ssa_6, ssa_7
	vec1 32 ssa_20 = fmul ssa_18, ssa_5
	vec1 32 ssa_21 = fmul ssa_19, ssa_5
	vec1 32 ssa_22 = ffma ssa_20, ssa_8, ssa_11.x
	vec1 32 ssa_23 = ffma ssa_21, ssa_8, ssa_14
	vec4 32 ssa_24 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_25 = fmul ssa_22, ssa_24.x
	vec1 32 ssa_26 = fmul ssa_23, ssa_24.y
	vec2 32 ssa_27 = vec2 ssa_25, ssa_26
	vec4 32 ssa_28 = tex ssa_10 (texture_deref), ssa_10 (sampler_deref), ssa_27 (coord)
	vec1 32 ssa_29 = fmul ssa_28.x, ssa_4
	vec1 32 ssa_30 = fmul ssa_28.y, ssa_4
	vec1 32 ssa_31 = fmul ssa_28.z, ssa_4
	vec1 32 ssa_32 = ffma ssa_28.w, ssa_4, ssa_9
	vec1 32 ssa_33 = fmin ssa_9, ssa_32
	vec1 32 ssa_34 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_35 = vec4 ssa_29, ssa_30, ssa_31, ssa_33
	intrinsic store_deref (ssa_34, ssa_35) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 25
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 2, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 3, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 0, i32 0, i32 %5) #2
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 1, i32 0, i32 %5) #2
  %33 = ptrtoint float addrspace(6)* %2 to i32
  %34 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %33, i32 0
  %35 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 16, i32 0) #2
  %36 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 20, i32 0) #2
  %37 = call nsz arcp contract float @llvm.fma.f32(float %15, float %35, float %36) #2
  %38 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %39 = load <8 x i32>, <8 x i32> addrspace(6)* %38, align 32, !invariant.load !0
  %40 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %41 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %40, i32 67, !amdgpu.uniform !0
  %42 = load <4 x i32>, <4 x i32> addrspace(6)* %41, align 16, !invariant.load !0
  %43 = call <2 x float> @llvm.amdgcn.image.sample.2d.v2f32.f32(i32 12, float %26, float %28, <8 x i32> %39, <4 x i32> %42, i1 false, i32 0, i32 0)
  %44 = extractelement <2 x float> %43, i32 0
  %45 = call nsz arcp contract float @llvm.fma.f32(float %44, float 2.000000e+00, float -1.000000e+00) #2
  %46 = extractelement <2 x float> %43, i32 1
  %47 = call nsz arcp contract float @llvm.fma.f32(float %46, float 2.000000e+00, float -1.000000e+00) #2
  %48 = fmul nsz arcp contract float %45, %32
  %49 = fmul nsz arcp contract float %47, %32
  %50 = call nsz arcp contract float @llvm.fma.f32(float %48, float 1.000000e+02, float %14) #2
  %51 = call nsz arcp contract float @llvm.fma.f32(float %49, float 1.000000e+02, float %37) #2
  %52 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 0, i32 0) #2
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %34, i32 4, i32 0) #2
  %54 = fmul nsz arcp contract float %50, %52
  %55 = fmul nsz arcp contract float %51, %53
  %56 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %57 = load <8 x i32>, <8 x i32> addrspace(6)* %56, align 32, !invariant.load !0
  %58 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %40, i32 71, !amdgpu.uniform !0
  %59 = load <4 x i32>, <4 x i32> addrspace(6)* %58, align 16, !invariant.load !0
  %60 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %54, float %55, <8 x i32> %57, <4 x i32> %59, i1 false, i32 0, i32 0) #5
  %61 = extractelement <4 x float> %60, i32 0
  %62 = fmul nsz arcp contract float %61, %30
  %63 = extractelement <4 x float> %60, i32 1
  %64 = fmul nsz arcp contract float %63, %30
  %65 = extractelement <4 x float> %60, i32 2
  %66 = fmul nsz arcp contract float %65, %30
  %67 = extractelement <4 x float> %60, i32 3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %67, float %30, float 1.000000e+00) #2
  %69 = call nsz arcp contract float @llvm.minnum.f32(float %68, float 1.000000e+00) #2
  %70 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %71 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %70, float %62, 5
  %72 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %71, float %64, 6
  %73 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %72, float %66, 7
  %74 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %73, float %69, 8
  %75 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %74, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %75
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.rcp.f32(float) #1

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.minnum.f32(float, float) #3

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.image.sample.2d.v2f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #4

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readonly }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_FRAGMENT
name: GLSL0
inputs: 0
outputs: 1
uniforms: 6
shared: 0
decl_var uniform INTERP_MODE_NONE vec4[3] gl_CurrentAttribFragMESA (0, 12, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_1 = load_const (0x00000050 /* 0.000000 */)
	vec4 32 ssa_2 = intrinsic load_ubo (ssa_0, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_3 = deref_var &gl_FragColor (shader_out vec4) 
	intrinsic store_deref (ssa_3, ssa_2) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 26
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = ptrtoint float addrspace(6)* %2 to i32
  %23 = insertelement <4 x i32> <i32 undef, i32 32768, i32 96, i32 822177708>, i32 %22, i32 0
  %24 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %23, i32 80, i32 0) #1
  %25 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %23, i32 84, i32 0) #1
  %26 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %23, i32 88, i32 0) #1
  %27 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %23, i32 92, i32 0) #1
  %28 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %29 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %28, float %24, 5
  %30 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %29, float %25, 6
  %31 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %30, float %26, 7
  %32 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %31, float %27, 8
  %33 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %32, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %33
}

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #1

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone }

shader: MESA_SHADER_VERTEX
name: ARB0
inputs: 0
outputs: 1
uniforms: 5
shared: 0
decl_var uniform INTERP_MODE_NONE vec4[5] state..internal.current[0] (0, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 out_0 (VARYING_SLOT_POS.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_1 = intrinsic load_ubo (ssa_0, ssa_0) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_2 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_3 = intrinsic load_ubo (ssa_0, ssa_2) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_4 = fmul ssa_1.x, ssa_3.x
	vec1 32 ssa_5 = fmul ssa_1.x, ssa_3.y
	vec1 32 ssa_6 = fmul ssa_1.x, ssa_3.z
	vec1 32 ssa_7 = fmul ssa_1.x, ssa_3.w
	vec1 32 ssa_8 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_9 = intrinsic load_ubo (ssa_0, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = ffma ssa_1.y, ssa_9.x, ssa_4
	vec1 32 ssa_11 = ffma ssa_1.y, ssa_9.y, ssa_5
	vec1 32 ssa_12 = ffma ssa_1.y, ssa_9.z, ssa_6
	vec1 32 ssa_13 = ffma ssa_1.y, ssa_9.w, ssa_7
	vec1 32 ssa_14 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_15 = intrinsic load_ubo (ssa_0, ssa_14) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_16 = ffma ssa_1.z, ssa_15.x, ssa_10
	vec1 32 ssa_17 = ffma ssa_1.z, ssa_15.y, ssa_11
	vec1 32 ssa_18 = ffma ssa_1.z, ssa_15.z, ssa_12
	vec1 32 ssa_19 = ffma ssa_1.z, ssa_15.w, ssa_13
	vec1 32 ssa_20 = load_const (0x00000040 /* 0.000000 */)
	vec4 32 ssa_21 = intrinsic load_ubo (ssa_0, ssa_20) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_22 = ffma ssa_1.w, ssa_21.x, ssa_16
	vec1 32 ssa_23 = ffma ssa_1.w, ssa_21.y, ssa_17
	vec1 32 ssa_24 = ffma ssa_1.w, ssa_21.z, ssa_18
	vec1 32 ssa_25 = ffma ssa_1.w, ssa_21.w, ssa_19
	vec4 32 ssa_26 = vec4 ssa_22, ssa_23, ssa_24, ssa_25
	vec1 32 ssa_27 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_27, ssa_26) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 27
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 %17, i32 %18, i32 %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 %24, i32 %25) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %26 = and i32 %3, 251658240
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %28 = lshr i32 %2, 12
  %29 = and i32 %28, 511
  %30 = lshr i32 %2, 10
  %31 = and i32 %30, 2093056
  %32 = or i32 %31, %29
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %32) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %33 = lshr i32 %3, 8
  %34 = and i32 %33, 255
  %35 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %36 = icmp ult i32 %35, %34
  br i1 %36, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %37 = bitcast i32 %17 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %37, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %38 = and i32 %3, 255
  %39 = icmp ult i32 %35, %38
  br i1 %39, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %40 = ptrtoint float addrspace(6)* %10 to i32
  %41 = insertelement <4 x i32> <i32 undef, i32 32768, i32 80, i32 822177708>, i32 %40, i32 0
  %42 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 0, i32 0) #3
  %43 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 4, i32 0) #3
  %44 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 8, i32 0) #3
  %45 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 12, i32 0) #3
  %46 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 16, i32 0) #3
  %47 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 20, i32 0) #3
  %48 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 24, i32 0) #3
  %49 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 28, i32 0) #3
  %50 = fmul nsz arcp contract float %42, %46
  %51 = fmul nsz arcp contract float %42, %47
  %52 = fmul nsz arcp contract float %42, %48
  %53 = fmul nsz arcp contract float %42, %49
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 32, i32 0) #3
  %55 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 36, i32 0) #3
  %56 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 40, i32 0) #3
  %57 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 44, i32 0) #3
  %58 = call nsz arcp contract float @llvm.fma.f32(float %43, float %54, float %50) #3
  %59 = call nsz arcp contract float @llvm.fma.f32(float %43, float %55, float %51) #3
  %60 = call nsz arcp contract float @llvm.fma.f32(float %43, float %56, float %52) #3
  %61 = call nsz arcp contract float @llvm.fma.f32(float %43, float %57, float %53) #3
  %62 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 48, i32 0) #3
  %63 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 52, i32 0) #3
  %64 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 56, i32 0) #3
  %65 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 60, i32 0) #3
  %66 = call nsz arcp contract float @llvm.fma.f32(float %44, float %62, float %58) #3
  %67 = call nsz arcp contract float @llvm.fma.f32(float %44, float %63, float %59) #3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %44, float %64, float %60) #3
  %69 = call nsz arcp contract float @llvm.fma.f32(float %44, float %65, float %61) #3
  %70 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 64, i32 0) #3
  %71 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 68, i32 0) #3
  %72 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 72, i32 0) #3
  %73 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %41, i32 76, i32 0) #3
  %74 = call nsz arcp contract float @llvm.fma.f32(float %45, float %70, float %66) #3
  %75 = call nsz arcp contract float @llvm.fma.f32(float %45, float %71, float %67) #3
  %76 = call nsz arcp contract float @llvm.fma.f32(float %45, float %72, float %68) #3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %45, float %73, float %69) #3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %74, float %75, float %76, float %77, i1 true, i1 true) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #5

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

radeonsi: Compiling shader 28
Vertex Shader Prolog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> @vs_prolog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, i32 inreg %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, i32 inreg %20, i32 inreg %21, i32 inreg %22, i32 inreg %23, i32 inreg %24, i32 inreg %25, i32 inreg %26, i32 inreg %27, i32 inreg %28, i32 inreg %29, i32 inreg %30, i32 inreg %31, i32 %32, i32 %33, i32 %34, i32 %35, i32 %36, i32 %37, i32 %38, i32 %39, i32 %40) #0 {
main_body:
  call void @llvm.amdgcn.init.exec.from.input(i32 %3, i32 0) #1
  %41 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %0, 0
  %42 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %41, i32 %1, 1
  %43 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %42, i32 %2, 2
  %44 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %43, i32 %3, 3
  %45 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %44, i32 %4, 4
  %46 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %45, i32 %5, 5
  %47 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %46, i32 %6, 6
  %48 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %47, i32 %7, 7
  %49 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %48, i32 %8, 8
  %50 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %49, i32 %9, 9
  %51 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %50, i32 %10, 10
  %52 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %51, i32 %11, 11
  %53 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %52, i32 %12, 12
  %54 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %53, i32 %13, 13
  %55 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %54, i32 %14, 14
  %56 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %55, i32 %15, 15
  %57 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %56, i32 %16, 16
  %58 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %57, i32 %17, 17
  %59 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %58, i32 %18, 18
  %60 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %59, i32 %19, 19
  %61 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %60, i32 %20, 20
  %62 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %61, i32 %21, 21
  %63 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %62, i32 %22, 22
  %64 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %63, i32 %23, 23
  %65 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %64, i32 %24, 24
  %66 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %65, i32 %25, 25
  %67 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %66, i32 %26, 26
  %68 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %67, i32 %27, 27
  %69 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %68, i32 %28, 28
  %70 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %69, i32 %29, 29
  %71 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %70, i32 %30, 30
  %72 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %71, i32 %31, 31
  %73 = bitcast i32 %32 to float
  %74 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %72, float %73, 32
  %75 = bitcast i32 %33 to float
  %76 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %74, float %75, 33
  %77 = bitcast i32 %34 to float
  %78 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %76, float %77, 34
  %79 = bitcast i32 %35 to float
  %80 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %78, float %79, 35
  %81 = bitcast i32 %36 to float
  %82 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %80, float %81, 36
  %83 = bitcast i32 %37 to float
  %84 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %82, float %83, 37
  %85 = bitcast i32 %38 to float
  %86 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %84, float %85, 38
  %87 = bitcast i32 %39 to float
  %88 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %86, float %87, 39
  %89 = bitcast i32 %40 to float
  %90 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %88, float %89, 40
  %91 = add i32 %37, %13
  %92 = bitcast i32 %91 to float
  %93 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %90, float %92, 41
  %94 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %93, float %92, 42
  %95 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %94, float %92, 43
  ret <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float }> %95
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec.from.input(i32, i32 immarg) #1

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB0_0:
	s_bfe_u32 s32, s3, 0x70000   ; 93A0FF03 00070000
	s_bfm_b32 exec_lo, s32, 0    ; 927E8020
	s_cmp_eq_u32 s32, 32         ; BF06A020
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
	v_mov_b32_e32 v11, v9        ; 7E160309
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                  ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                            ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                      ; BE80030A
	s_cmp_lg_u32 s1, 0                                     ; BF078001
	s_cbranch_scc1 BB0_2                                   ; BF850000
	s_lshr_b32 s1, s2, 10                                  ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                              ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                             ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                    ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                    ; BF900009
BB0_2:
	s_bfe_u32 s1, s3, 0x80008                              ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                       ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                        ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                          ; BE813C6A
	s_cbranch_execz BB0_4                                  ; BF880000
BB0_3:
	exp prim v0, off, off, off done                        ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                    ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                          ; 887E017E
	s_and_b32 s1, s3, 0xff                                 ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                        ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                          ; BE813C6A
	s_cbranch_execz BB0_6                                  ; BF880000
BB0_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen  ; E00C2000 80050009
	buffer_load_format_xyzw v[4:7], v10, s[24:27], 0 idxen ; E00C2000 8006040A
	buffer_load_format_xy v[8:9], v11, s[28:31], 0 idxen   ; E0042000 8007080B
	s_mov_b32 s3, 0x31016fac                               ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                       ; BE820390
	s_mov_b32 s1, 0x8000                                   ; BE8103FF 00008000
	s_buffer_load_dwordx2 s[0:1], s[0:3], 0x8              ; F4240000 FA000008
	s_waitcnt lgkmcnt(0)                                   ; BF8CC07F
	v_rcp_f32_e32 v10, s0                                  ; 7E145400
	v_rcp_f32_e32 v11, s1                                  ; 7E165401
	s_waitcnt vmcnt(2)                                     ; BF8C3F72
	v_mul_f32_e32 v0, v0, v10                              ; 10001500
	v_mul_f32_e32 v1, v1, v11                              ; 10021701
	v_fma_f32 v0, v0, 2.0, -1.0                            ; D54B0000 03CDE900
	v_fma_f32 v1, v1, -2.0, 1.0                            ; D54B0001 03C9EB01
	exp pos0 v0, v1, v2, v3 done vm                        ; F80018CF 03020100
	s_waitcnt vmcnt(1)                                     ; BF8C3F71
	exp param0 v4, v5, v6, v7                              ; F800020F 07060504
	s_waitcnt vmcnt(0)                                     ; BF8C3F70
	exp param1 v8, v9, v0, v0                              ; F800021F 00000908
BB0_6:
	s_endpgm                                               ; BF810000

*** SHADER STATS ***
SGPRS: 40
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 276 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


radeonsi: Compiling shader 29
Fragment Shader Epilog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps void @ps_epilog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, float inreg %4, float %5, float %6, float %7, float %8, float %9, float %10, float %11, float %12, float %13, float %14, float %15, float %16, float %17, float %18, float %19) #0 {
main_body:
  %20 = fcmp nsz arcp contract ogt float %8, %4
  call void @llvm.amdgcn.kill(i1 %20) #1
  %21 = call nsz arcp contract <2 x half> @llvm.amdgcn.cvt.pkrtz(float %5, float %6) #4
  %22 = call nsz arcp contract <2 x half> @llvm.amdgcn.cvt.pkrtz(float %7, float %8) #4
  %23 = bitcast <2 x half> %21 to <2 x i16>
  %24 = bitcast <2 x half> %22 to <2 x i16>
  call void @llvm.amdgcn.exp.compr.v2i16(i32 0, i32 15, <2 x i16> %23, <2 x i16> %24, i1 true, i1 true) #1
  ret void
}

; Function Attrs: nounwind
declare void @llvm.amdgcn.kill(i1) #1

; Function Attrs: nounwind readnone speculatable
declare <2 x half> @llvm.amdgcn.cvt.pkrtz(float, float) #2

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.compr.v2i16(i32 immarg, i32 immarg, <2 x i16>, <2 x i16>, i1 immarg, i1 immarg) #3

attributes #0 = { "InitialPSInputAddr"="0xffffff" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone speculatable }
attributes #3 = { inaccessiblememonly nounwind }
attributes #4 = { nounwind readnone }

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b64 s[6:7], exec                                                        ; BE86047E
	s_wqm_b64 exec, exec                                                          ; BEFE0A7E
	s_mov_b32 s16, s3                                                             ; BE900303
	s_movk_i32 s17, 0x8000                                                        ; B0118000
	s_mov_b32 m0, s5                                                              ; BEFC0305
	s_mov_b32 s0, s2                                                              ; BE800302
	s_mov_b32 s3, 0x31016fac                                                      ; BE8303FF 31016FAC
	s_mov_b32 s2, 32                                                              ; BE8203A0
	s_load_dwordx8 s[8:15], s[16:17], 0x400                                       ; F40C0208 FA000400
	s_load_dwordx4 s[16:19], s[16:17], 0x430                                      ; F4080408 FA000430
	v_interp_p1_f32_e32 v4, v2, attr0.x                                           ; C8100002
	v_interp_p1_f32_e32 v5, v2, attr0.y                                           ; C8140102
	v_interp_p1_f32_e32 v6, v2, attr0.z                                           ; C8180202
	v_interp_p1_f32_e32 v10, v2, attr0.w                                          ; C8280302
	v_interp_p1_f32_e32 v0, v2, attr1.x                                           ; C8000402
	v_interp_p1_f32_e32 v1, v2, attr1.y                                           ; C8040502
	v_interp_p2_f32_e32 v4, v3, attr0.x                                           ; C8110003
	v_interp_p2_f32_e32 v5, v3, attr0.y                                           ; C8150103
	v_interp_p2_f32_e32 v6, v3, attr0.z                                           ; C8190203
	v_interp_p2_f32_e32 v10, v3, attr0.w                                          ; C8290303
	v_interp_p2_f32_e32 v0, v3, attr1.x                                           ; C8010403
	v_interp_p2_f32_e32 v1, v3, attr1.y                                           ; C8050503
	s_mov_b32 s1, 0x8000                                                          ; BE8103FF 00008000
	s_and_b64 exec, exec, s[6:7]                                                  ; 87FE067E
	s_waitcnt lgkmcnt(0)                                                          ; BF8CC07F
	image_sample v[18:21], v[0:1], s[8:15], s[16:19] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00821200
	s_buffer_load_dwordx2 s[6:7], s[0:3], 0x0                                     ; F4240180 FA000000
	s_buffer_load_dword s5, s[0:3], 0x8                                           ; F4200140 FA000008
	s_buffer_load_dwordx2 s[0:1], s[0:3], 0xc                                     ; F4240000 FA00000C
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_mul_f32_e32 v0, v18, v4                                                     ; 10000912
	v_mul_f32_e32 v1, v19, v5                                                     ; 10020B13
	v_mul_f32_e32 v2, v20, v6                                                     ; 10040D14
	v_mul_f32_e32 v3, v21, v10                                                    ; 10061515
	s_waitcnt lgkmcnt(0)                                                          ; BF8CC07F
	v_fma_f32 v0, v0, s6, s1                                                      ; D54B0000 00040D00
	v_fma_f32 v1, v1, s7, s1                                                      ; D54B0001 00040F01
	v_fma_f32 v2, v2, s5, s1                                                      ; D54B0002 00040B02
	v_mul_f32_e32 v3, s0, v3                                                      ; 10060600
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 24
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 228 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_VERTEX
name: GLSL24
inputs: 2
outputs: 2
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_4, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_5 = deref_var &v_uv0 (shader_out float) 
	vec1 32 ssa_6 = mov ssa_3.x
	intrinsic store_deref (ssa_5, ssa_6) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_7 = deref_var &v_uv0@0 (shader_out float) 
	vec1 32 ssa_8 = mov ssa_3.y
	intrinsic store_deref (ssa_7, ssa_8) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 30
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = extractelement <4 x float> %47, i32 0
  %52 = extractelement <4 x float> %47, i32 1
  %53 = extractelement <4 x float> %47, i32 2
  %54 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %51, float %52, float %53, float %54, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %49, float %50, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL24
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_4 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_5 = vec2 ssa_2, ssa_3
	vec4 32 ssa_6 = tex ssa_4 (texture_deref), ssa_4 (sampler_deref), ssa_5 (coord)
	vec1 32 ssa_7 = deref_var &gl_FragColor (shader_out vec4) 
	intrinsic store_deref (ssa_7, ssa_6) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 31
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #3
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #3
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #3
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #3
  %29 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %30 = load <8 x i32>, <8 x i32> addrspace(6)* %29, align 32, !invariant.load !0
  %31 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %32 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %31, i32 67, !amdgpu.uniform !0
  %33 = load <4 x i32>, <4 x i32> addrspace(6)* %32, align 16, !invariant.load !0
  %34 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %30, <4 x i32> %33, i1 false, i32 0, i32 0) #4
  %35 = extractelement <4 x float> %34, i32 0
  %36 = extractelement <4 x float> %34, i32 1
  %37 = extractelement <4 x float> %34, i32 2
  %38 = extractelement <4 x float> %34, i32 3
  %39 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %40 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %39, float %35, 5
  %41 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %40, float %36, 6
  %42 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %41, float %37, 7
  %43 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %42, float %38, 8
  %44 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %43, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %44
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone }
attributes #4 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL28
inputs: 2
outputs: 3
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float pixelWidth (0, 0, 0)
decl_var uniform INTERP_MODE_NONE float pixelHeight (1, 1, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv2 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv3 (VARYING_SLOT_VAR0.w, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv4 (VARYING_SLOT_VAR1.x, 8, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv4@1 (VARYING_SLOT_VAR1.y, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0xbf000000 /* -0.500000 */)
	vec1 32 ssa_5 = load_const (0x3f000000 /* 0.500000 */)
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_7 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_8 = load_const (0x00000004 /* 0.000000 */)
	vec1 32 ssa_9 = intrinsic load_ubo (ssa_6, ssa_8) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_10 = ffma ssa_7, ssa_4, ssa_3.x
	vec1 32 ssa_11 = ffma ssa_9, ssa_4, ssa_3.y
	vec1 32 ssa_12 = ffma ssa_7, ssa_5, ssa_3.x
	vec1 32 ssa_13 = ffma ssa_9, ssa_5, ssa_3.y
	vec1 32 ssa_14 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_14, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_15 = deref_var &v_uv0 (shader_out float) 
	vec1 32 ssa_16 = mov ssa_3.x
	intrinsic store_deref (ssa_15, ssa_16) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_17 = deref_var &v_uv0@0 (shader_out float) 
	vec1 32 ssa_18 = mov ssa_3.y
	intrinsic store_deref (ssa_17, ssa_18) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_19 = deref_var &v_uv2 (shader_out float) 
	intrinsic store_deref (ssa_19, ssa_11) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_20 = deref_var &v_uv3 (shader_out float) 
	intrinsic store_deref (ssa_20, ssa_10) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_21 = deref_var &v_uv4 (shader_out float) 
	intrinsic store_deref (ssa_21, ssa_12) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_22 = deref_var &v_uv4@1 (shader_out float) 
	intrinsic store_deref (ssa_22, ssa_13) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 32
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = ptrtoint float addrspace(6)* %10 to i32
  %52 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %51, i32 0
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 0, i32 0) #3
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 4, i32 0) #3
  %55 = call nsz arcp contract float @llvm.fma.f32(float %53, float -5.000000e-01, float %49) #3
  %56 = call nsz arcp contract float @llvm.fma.f32(float %54, float -5.000000e-01, float %50) #3
  %57 = call nsz arcp contract float @llvm.fma.f32(float %53, float 5.000000e-01, float %49) #3
  %58 = call nsz arcp contract float @llvm.fma.f32(float %54, float 5.000000e-01, float %50) #3
  %59 = extractelement <4 x float> %47, i32 0
  %60 = extractelement <4 x float> %47, i32 1
  %61 = extractelement <4 x float> %47, i32 2
  %62 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %59, float %60, float %61, float %62, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %49, float %50, float %56, float %55, i1 false, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 33, i32 15, float %57, float %58, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL28
inputs: 2
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (2, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (3, 1, 1)
decl_var uniform INTERP_MODE_NONE sampler2D texture2 (4, 2, 2)
decl_var shader_in INTERP_MODE_NONE float v_uv2 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv3 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv4 (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv4@1 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_uv2 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_uv3 */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* v_uv4 */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* v_uv4 */
	vec1 32 ssa_8 = load_const (0x3e800000 /* 0.250000 */)
	vec1 32 ssa_9 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_10 = vec2 ssa_3, ssa_2
	vec4 32 ssa_11 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_10 (coord)
	vec2 32 ssa_12 = vec2 ssa_6, ssa_2
	vec4 32 ssa_13 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_12 (coord)
	vec1 32 ssa_14 = fadd ssa_11.x, ssa_13.x
	vec1 32 ssa_15 = fmul ssa_8, ssa_14
	vec1 32 ssa_16 = fadd ssa_11.y, ssa_13.y
	vec1 32 ssa_17 = fmul ssa_8, ssa_16
	vec1 32 ssa_18 = fadd ssa_11.z, ssa_13.z
	vec1 32 ssa_19 = fmul ssa_8, ssa_18
	vec1 32 ssa_20 = fadd ssa_11.w, ssa_13.w
	vec1 32 ssa_21 = fmul ssa_8, ssa_20
	vec2 32 ssa_22 = vec2 ssa_3, ssa_7
	vec4 32 ssa_23 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_22 (coord)
	vec1 32 ssa_24 = ffma ssa_23.x, ssa_8, ssa_15
	vec1 32 ssa_25 = ffma ssa_23.y, ssa_8, ssa_17
	vec1 32 ssa_26 = ffma ssa_23.z, ssa_8, ssa_19
	vec1 32 ssa_27 = ffma ssa_23.w, ssa_8, ssa_21
	vec2 32 ssa_28 = vec2 ssa_6, ssa_7
	vec4 32 ssa_29 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_28 (coord)
	vec1 32 ssa_30 = ffma ssa_29.x, ssa_8, ssa_24
	vec1 32 ssa_31 = ffma ssa_29.y, ssa_8, ssa_25
	vec1 32 ssa_32 = ffma ssa_29.z, ssa_8, ssa_26
	vec1 32 ssa_33 = ffma ssa_29.w, ssa_8, ssa_27
	vec1 32 ssa_34 = deref_var &texture2 (uniform sampler2D) 
	vec2 32 ssa_35 = vec2 ssa_4, ssa_5
	vec4 32 ssa_36 = tex ssa_34 (texture_deref), ssa_34 (sampler_deref), ssa_35 (coord)
	vec1 32 ssa_37 = deref_var &texture1 (uniform sampler2D) 
	vec4 32 ssa_38 = tex ssa_37 (texture_deref), ssa_37 (sampler_deref), ssa_35 (coord)
	vec1 32 ssa_39 = fneg ssa_30
	vec1 32 ssa_40 = fneg ssa_31
	vec1 32 ssa_41 = fneg ssa_32
	vec1 32 ssa_42 = fneg ssa_33
	vec1 32 ssa_43 = fadd ssa_38.x, ssa_39
	vec1 32 ssa_44 = fadd ssa_38.y, ssa_40
	vec1 32 ssa_45 = fadd ssa_38.z, ssa_41
	vec1 32 ssa_46 = fadd ssa_38.w, ssa_42
	vec1 32 ssa_47 = ffma ssa_36.w, ssa_43, ssa_30
	vec1 32 ssa_48 = ffma ssa_36.w, ssa_44, ssa_31
	vec1 32 ssa_49 = ffma ssa_36.w, ssa_45, ssa_32
	vec1 32 ssa_50 = ffma ssa_36.w, ssa_46, ssa_33
	vec1 32 ssa_51 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_52 = vec4 ssa_47, ssa_48, ssa_49, ssa_50
	intrinsic store_deref (ssa_51, ssa_52) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 33
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 2, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 3, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 0, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 1, i32 0, i32 %5) #4
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #4
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 0, i32 1, i32 %5) #4
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #4
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 1, i32 1, i32 %5) #4
  %37 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %38 = load <8 x i32>, <8 x i32> addrspace(6)* %37, align 32, !invariant.load !0
  %39 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %40 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 67, !amdgpu.uniform !0
  %41 = load <4 x i32>, <4 x i32> addrspace(6)* %40, align 16, !invariant.load !0
  %42 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %28, float %26, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %43 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %26, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %44 = extractelement <4 x float> %42, i32 0
  %45 = extractelement <4 x float> %43, i32 0
  %46 = fadd nsz arcp contract float %44, %45
  %47 = fmul nsz arcp contract float %46, 2.500000e-01
  %48 = extractelement <4 x float> %42, i32 1
  %49 = extractelement <4 x float> %43, i32 1
  %50 = fadd nsz arcp contract float %48, %49
  %51 = fmul nsz arcp contract float %50, 2.500000e-01
  %52 = extractelement <4 x float> %42, i32 2
  %53 = extractelement <4 x float> %43, i32 2
  %54 = fadd nsz arcp contract float %52, %53
  %55 = fmul nsz arcp contract float %54, 2.500000e-01
  %56 = extractelement <4 x float> %42, i32 3
  %57 = extractelement <4 x float> %43, i32 3
  %58 = fadd nsz arcp contract float %56, %57
  %59 = fmul nsz arcp contract float %58, 2.500000e-01
  %60 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %28, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %61 = extractelement <4 x float> %60, i32 0
  %62 = call nsz arcp contract float @llvm.fma.f32(float %61, float 2.500000e-01, float %47) #4
  %63 = extractelement <4 x float> %60, i32 1
  %64 = call nsz arcp contract float @llvm.fma.f32(float %63, float 2.500000e-01, float %51) #4
  %65 = extractelement <4 x float> %60, i32 2
  %66 = call nsz arcp contract float @llvm.fma.f32(float %65, float 2.500000e-01, float %55) #4
  %67 = extractelement <4 x float> %60, i32 3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %67, float 2.500000e-01, float %59) #4
  %69 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %70 = extractelement <4 x float> %69, i32 0
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float 2.500000e-01, float %62) #4
  %72 = extractelement <4 x float> %69, i32 1
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float 2.500000e-01, float %64) #4
  %74 = extractelement <4 x float> %69, i32 2
  %75 = call nsz arcp contract float @llvm.fma.f32(float %74, float 2.500000e-01, float %66) #4
  %76 = extractelement <4 x float> %69, i32 3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %76, float 2.500000e-01, float %68) #4
  %78 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 36, !amdgpu.uniform !0
  %79 = load <8 x i32>, <8 x i32> addrspace(6)* %78, align 32, !invariant.load !0
  %80 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 75, !amdgpu.uniform !0
  %81 = load <4 x i32>, <4 x i32> addrspace(6)* %80, align 16, !invariant.load !0
  %82 = call float @llvm.amdgcn.image.sample.2d.f32.f32(i32 8, float %30, float %32, <8 x i32> %79, <4 x i32> %81, i1 false, i32 0, i32 0)
  %83 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %84 = load <8 x i32>, <8 x i32> addrspace(6)* %83, align 32, !invariant.load !0
  %85 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 71, !amdgpu.uniform !0
  %86 = load <4 x i32>, <4 x i32> addrspace(6)* %85, align 16, !invariant.load !0
  %87 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %30, float %32, <8 x i32> %84, <4 x i32> %86, i1 false, i32 0, i32 0) #5
  %88 = extractelement <4 x float> %87, i32 0
  %89 = fsub nsz arcp contract float %88, %71
  %90 = extractelement <4 x float> %87, i32 1
  %91 = fsub nsz arcp contract float %90, %73
  %92 = extractelement <4 x float> %87, i32 2
  %93 = fsub nsz arcp contract float %92, %75
  %94 = extractelement <4 x float> %87, i32 3
  %95 = fsub nsz arcp contract float %94, %77
  %96 = call nsz arcp contract float @llvm.fma.f32(float %82, float %89, float %71) #4
  %97 = call nsz arcp contract float @llvm.fma.f32(float %82, float %91, float %73) #4
  %98 = call nsz arcp contract float @llvm.fma.f32(float %82, float %93, float %75) #4
  %99 = call nsz arcp contract float @llvm.fma.f32(float %82, float %95, float %77) #4
  %100 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %101 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %100, float %96, 5
  %102 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %101, float %97, 6
  %103 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %102, float %98, 7
  %104 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %103, float %99, 8
  %105 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %104, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %105
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

; Function Attrs: nounwind readonly
declare float @llvm.amdgcn.image.sample.2d.f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_FRAGMENT
name: GLSL29
inputs: 2
outputs: 1
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float alphaBias (2, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (4, 1, 1)
decl_var uniform INTERP_MODE_NONE sampler2D texture2 (5, 2, 2)
decl_var shader_in INTERP_MODE_NONE float v_uv2 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv3 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv4 (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv4@1 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_uv2 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_uv3 */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* v_uv4 */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* v_uv4 */
	vec1 32 ssa_8 = load_const (0x3e800000 /* 0.250000 */)
	vec1 32 ssa_9 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_10 = vec2 ssa_3, ssa_2
	vec4 32 ssa_11 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_10 (coord)
	vec2 32 ssa_12 = vec2 ssa_6, ssa_2
	vec4 32 ssa_13 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_12 (coord)
	vec1 32 ssa_14 = fadd ssa_11.x, ssa_13.x
	vec1 32 ssa_15 = fmul ssa_8, ssa_14
	vec1 32 ssa_16 = fadd ssa_11.y, ssa_13.y
	vec1 32 ssa_17 = fmul ssa_8, ssa_16
	vec1 32 ssa_18 = fadd ssa_11.z, ssa_13.z
	vec1 32 ssa_19 = fmul ssa_8, ssa_18
	vec1 32 ssa_20 = fadd ssa_11.w, ssa_13.w
	vec1 32 ssa_21 = fmul ssa_8, ssa_20
	vec2 32 ssa_22 = vec2 ssa_3, ssa_7
	vec4 32 ssa_23 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_22 (coord)
	vec1 32 ssa_24 = ffma ssa_23.x, ssa_8, ssa_15
	vec1 32 ssa_25 = ffma ssa_23.y, ssa_8, ssa_17
	vec1 32 ssa_26 = ffma ssa_23.z, ssa_8, ssa_19
	vec1 32 ssa_27 = ffma ssa_23.w, ssa_8, ssa_21
	vec2 32 ssa_28 = vec2 ssa_6, ssa_7
	vec4 32 ssa_29 = tex ssa_9 (texture_deref), ssa_9 (sampler_deref), ssa_28 (coord)
	vec1 32 ssa_30 = ffma ssa_29.x, ssa_8, ssa_24
	vec1 32 ssa_31 = ffma ssa_29.y, ssa_8, ssa_25
	vec1 32 ssa_32 = ffma ssa_29.z, ssa_8, ssa_26
	vec1 32 ssa_33 = ffma ssa_29.w, ssa_8, ssa_27
	vec1 32 ssa_34 = deref_var &texture2 (uniform sampler2D) 
	vec2 32 ssa_35 = vec2 ssa_4, ssa_5
	vec4 32 ssa_36 = tex ssa_34 (texture_deref), ssa_34 (sampler_deref), ssa_35 (coord)
	vec1 32 ssa_37 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_38 = fmax ssa_36.w, ssa_37
	vec1 32 ssa_39 = deref_var &texture1 (uniform sampler2D) 
	vec4 32 ssa_40 = tex ssa_39 (texture_deref), ssa_39 (sampler_deref), ssa_35 (coord)
	vec1 32 ssa_41 = fneg ssa_30
	vec1 32 ssa_42 = fneg ssa_31
	vec1 32 ssa_43 = fneg ssa_32
	vec1 32 ssa_44 = fneg ssa_33
	vec1 32 ssa_45 = fadd ssa_40.x, ssa_41
	vec1 32 ssa_46 = fadd ssa_40.y, ssa_42
	vec1 32 ssa_47 = fadd ssa_40.z, ssa_43
	vec1 32 ssa_48 = fadd ssa_40.w, ssa_44
	vec1 32 ssa_49 = ffma ssa_38, ssa_45, ssa_30
	vec1 32 ssa_50 = ffma ssa_38, ssa_46, ssa_31
	vec1 32 ssa_51 = ffma ssa_38, ssa_47, ssa_32
	vec1 32 ssa_52 = ffma ssa_38, ssa_48, ssa_33
	vec1 32 ssa_53 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_54 = vec4 ssa_49, ssa_50, ssa_51, ssa_52
	intrinsic store_deref (ssa_53, ssa_54) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 34
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 2, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 3, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 0, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 1, i32 0, i32 %5) #4
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #4
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 0, i32 1, i32 %5) #4
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #4
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 1, i32 1, i32 %5) #4
  %37 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %38 = load <8 x i32>, <8 x i32> addrspace(6)* %37, align 32, !invariant.load !0
  %39 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %40 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 67, !amdgpu.uniform !0
  %41 = load <4 x i32>, <4 x i32> addrspace(6)* %40, align 16, !invariant.load !0
  %42 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %28, float %26, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %43 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %26, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %44 = extractelement <4 x float> %42, i32 0
  %45 = extractelement <4 x float> %43, i32 0
  %46 = fadd nsz arcp contract float %44, %45
  %47 = fmul nsz arcp contract float %46, 2.500000e-01
  %48 = extractelement <4 x float> %42, i32 1
  %49 = extractelement <4 x float> %43, i32 1
  %50 = fadd nsz arcp contract float %48, %49
  %51 = fmul nsz arcp contract float %50, 2.500000e-01
  %52 = extractelement <4 x float> %42, i32 2
  %53 = extractelement <4 x float> %43, i32 2
  %54 = fadd nsz arcp contract float %52, %53
  %55 = fmul nsz arcp contract float %54, 2.500000e-01
  %56 = extractelement <4 x float> %42, i32 3
  %57 = extractelement <4 x float> %43, i32 3
  %58 = fadd nsz arcp contract float %56, %57
  %59 = fmul nsz arcp contract float %58, 2.500000e-01
  %60 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %28, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %61 = extractelement <4 x float> %60, i32 0
  %62 = call nsz arcp contract float @llvm.fma.f32(float %61, float 2.500000e-01, float %47) #4
  %63 = extractelement <4 x float> %60, i32 1
  %64 = call nsz arcp contract float @llvm.fma.f32(float %63, float 2.500000e-01, float %51) #4
  %65 = extractelement <4 x float> %60, i32 2
  %66 = call nsz arcp contract float @llvm.fma.f32(float %65, float 2.500000e-01, float %55) #4
  %67 = extractelement <4 x float> %60, i32 3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %67, float 2.500000e-01, float %59) #4
  %69 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %70 = extractelement <4 x float> %69, i32 0
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float 2.500000e-01, float %62) #4
  %72 = extractelement <4 x float> %69, i32 1
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float 2.500000e-01, float %64) #4
  %74 = extractelement <4 x float> %69, i32 2
  %75 = call nsz arcp contract float @llvm.fma.f32(float %74, float 2.500000e-01, float %66) #4
  %76 = extractelement <4 x float> %69, i32 3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %76, float 2.500000e-01, float %68) #4
  %78 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 36, !amdgpu.uniform !0
  %79 = load <8 x i32>, <8 x i32> addrspace(6)* %78, align 32, !invariant.load !0
  %80 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 75, !amdgpu.uniform !0
  %81 = load <4 x i32>, <4 x i32> addrspace(6)* %80, align 16, !invariant.load !0
  %82 = call float @llvm.amdgcn.image.sample.2d.f32.f32(i32 8, float %30, float %32, <8 x i32> %79, <4 x i32> %81, i1 false, i32 0, i32 0)
  %83 = ptrtoint float addrspace(6)* %2 to i32
  %84 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %83, i32 0
  %85 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %84, i32 0, i32 0) #4
  %86 = call nsz arcp contract float @llvm.maxnum.f32(float %82, float %85) #4
  %87 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %88 = load <8 x i32>, <8 x i32> addrspace(6)* %87, align 32, !invariant.load !0
  %89 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 71, !amdgpu.uniform !0
  %90 = load <4 x i32>, <4 x i32> addrspace(6)* %89, align 16, !invariant.load !0
  %91 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %30, float %32, <8 x i32> %88, <4 x i32> %90, i1 false, i32 0, i32 0) #5
  %92 = extractelement <4 x float> %91, i32 0
  %93 = fsub nsz arcp contract float %92, %71
  %94 = extractelement <4 x float> %91, i32 1
  %95 = fsub nsz arcp contract float %94, %73
  %96 = extractelement <4 x float> %91, i32 2
  %97 = fsub nsz arcp contract float %96, %75
  %98 = extractelement <4 x float> %91, i32 3
  %99 = fsub nsz arcp contract float %98, %77
  %100 = call nsz arcp contract float @llvm.fma.f32(float %86, float %93, float %71) #4
  %101 = call nsz arcp contract float @llvm.fma.f32(float %86, float %95, float %73) #4
  %102 = call nsz arcp contract float @llvm.fma.f32(float %86, float %97, float %75) #4
  %103 = call nsz arcp contract float @llvm.fma.f32(float %86, float %99, float %77) #4
  %104 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %105 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %104, float %100, 5
  %106 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %105, float %101, 6
  %107 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %106, float %102, 7
  %108 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %107, float %103, 8
  %109 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %108, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %109
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.maxnum.f32(float, float) #3

; Function Attrs: nounwind readonly
declare float @llvm.amdgcn.image.sample.2d.f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL32
inputs: 2
outputs: 2
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 noiseUVMulAdd (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv1 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_uv1@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_5 = intrinsic load_ubo (ssa_4, ssa_4) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_6 = ffma ssa_3.x, ssa_5.x, ssa_5.z
	vec1 32 ssa_7 = ffma ssa_3.y, ssa_5.y, ssa_5.w
	vec1 32 ssa_8 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_8, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_9 = deref_var &v_uv0 (shader_out float) 
	vec1 32 ssa_10 = mov ssa_3.x
	intrinsic store_deref (ssa_9, ssa_10) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_11 = deref_var &v_uv0@0 (shader_out float) 
	vec1 32 ssa_12 = mov ssa_3.y
	intrinsic store_deref (ssa_11, ssa_12) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_13 = deref_var &v_uv1 (shader_out float) 
	intrinsic store_deref (ssa_13, ssa_6) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_14 = deref_var &v_uv1@1 (shader_out float) 
	intrinsic store_deref (ssa_14, ssa_7) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 35
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = ptrtoint float addrspace(6)* %10 to i32
  %52 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %51, i32 0
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 0, i32 0) #3
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 4, i32 0) #3
  %55 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 8, i32 0) #3
  %56 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 12, i32 0) #3
  %57 = call nsz arcp contract float @llvm.fma.f32(float %49, float %53, float %55) #3
  %58 = call nsz arcp contract float @llvm.fma.f32(float %50, float %54, float %56) #3
  %59 = extractelement <4 x float> %47, i32 0
  %60 = extractelement <4 x float> %47, i32 1
  %61 = extractelement <4 x float> %47, i32 2
  %62 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %59, float %60, float %61, float %62, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %49, float %50, float %57, float %58, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL32
inputs: 1
outputs: 1
uniforms: 2
shared: 0
decl_var uniform INTERP_MODE_NONE vec4 noiseMulAdd (1, 0, 0)
decl_var uniform INTERP_MODE_NONE float brightness (2, 4, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (3, 0, 0)
decl_var uniform INTERP_MODE_NONE sampler2D texture1 (4, 1, 1)
decl_var uniform INTERP_MODE_NONE sampler2D texture2 (5, 2, 2)
decl_var shader_in INTERP_MODE_NONE float v_uv0 (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv0@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv1 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv1@1 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_uv0 */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_uv0 */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_uv1 */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_uv1 */
	vec1 32 ssa_6 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_7 = load_const (0xbf800000 /* -1.000000 */)
	vec1 32 ssa_8 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_9 = vec2 ssa_2, ssa_3
	vec4 32 ssa_10 = tex ssa_8 (texture_deref), ssa_8 (sampler_deref), ssa_9 (coord)
	vec1 32 ssa_11 = deref_var &texture1 (uniform sampler2D) 
	vec4 32 ssa_12 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_9 (coord)
	vec1 32 ssa_13 = fadd ssa_10.y, ssa_12.y
	vec1 32 ssa_14 = fadd ssa_10.x, ssa_13
	vec1 32 ssa_15 = load_const (0x00000010 /* 0.000000 */)
	vec1 32 ssa_16 = intrinsic load_ubo (ssa_1, ssa_15) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_17 = fadd ssa_14, ssa_16
	vec1 32 ssa_18 = deref_var &texture2 (uniform sampler2D) 
	vec2 32 ssa_19 = vec2 ssa_4, ssa_5
	vec4 32 ssa_20 = tex ssa_18 (texture_deref), ssa_18 (sampler_deref), ssa_19 (coord)
	vec1 32 ssa_21 = ffma ssa_20.x, ssa_6, ssa_7
	vec4 32 ssa_22 = intrinsic load_ubo (ssa_1, ssa_1) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_23 = ffma ssa_17, ssa_22.x, ssa_22.y
	vec1 32 ssa_24 = ffma ssa_21, ssa_23, ssa_17
	vec1 32 ssa_25 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_26 = vec4 ssa_24, ssa_24, ssa_24, ssa_24
	intrinsic store_deref (ssa_25, ssa_26) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 36
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #3
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #3
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #3
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #3
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #3
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #3
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #3
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #3
  %33 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %34 = load <8 x i32>, <8 x i32> addrspace(6)* %33, align 32, !invariant.load !0
  %35 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %36 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %35, i32 67, !amdgpu.uniform !0
  %37 = load <4 x i32>, <4 x i32> addrspace(6)* %36, align 16, !invariant.load !0
  %38 = call <2 x float> @llvm.amdgcn.image.sample.2d.v2f32.f32(i32 3, float %26, float %28, <8 x i32> %34, <4 x i32> %37, i1 false, i32 0, i32 0)
  %39 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 34, !amdgpu.uniform !0
  %40 = load <8 x i32>, <8 x i32> addrspace(6)* %39, align 32, !invariant.load !0
  %41 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %35, i32 71, !amdgpu.uniform !0
  %42 = load <4 x i32>, <4 x i32> addrspace(6)* %41, align 16, !invariant.load !0
  %43 = call float @llvm.amdgcn.image.sample.2d.f32.f32(i32 2, float %26, float %28, <8 x i32> %40, <4 x i32> %42, i1 false, i32 0, i32 0)
  %44 = extractelement <2 x float> %38, i32 1
  %45 = fadd nsz arcp contract float %44, %43
  %46 = extractelement <2 x float> %38, i32 0
  %47 = fadd nsz arcp contract float %46, %45
  %48 = ptrtoint float addrspace(6)* %2 to i32
  %49 = insertelement <4 x i32> <i32 undef, i32 32768, i32 32, i32 822177708>, i32 %48, i32 0
  %50 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %49, i32 16, i32 0) #3
  %51 = fadd nsz arcp contract float %47, %50
  %52 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 36, !amdgpu.uniform !0
  %53 = load <8 x i32>, <8 x i32> addrspace(6)* %52, align 32, !invariant.load !0
  %54 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %35, i32 75, !amdgpu.uniform !0
  %55 = load <4 x i32>, <4 x i32> addrspace(6)* %54, align 16, !invariant.load !0
  %56 = call float @llvm.amdgcn.image.sample.2d.f32.f32(i32 1, float %30, float %32, <8 x i32> %53, <4 x i32> %55, i1 false, i32 0, i32 0)
  %57 = call nsz arcp contract float @llvm.fma.f32(float %56, float 2.000000e+00, float -1.000000e+00) #3
  %58 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %49, i32 0, i32 0) #3
  %59 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %49, i32 4, i32 0) #3
  %60 = call nsz arcp contract float @llvm.fma.f32(float %51, float %58, float %59) #3
  %61 = call nsz arcp contract float @llvm.fma.f32(float %57, float %60, float %51) #3
  %62 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %63 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %62, float %61, 5
  %64 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %63, float %61, 6
  %65 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %64, float %61, 7
  %66 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %65, float %61, 8
  %67 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %66, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %67
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #4

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.image.sample.2d.v2f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readonly
declare float @llvm.amdgcn.image.sample.2d.f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone }
attributes #4 = { nounwind readnone speculatable willreturn }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL36
inputs: 2
outputs: 3
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float pixelWidth (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[0],v_uv[1]@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[4] (VARYING_SLOT_VAR1.x, 8, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[4]@2 (VARYING_SLOT_VAR1.y, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x40510ff9 /* 3.266600 */)
	vec1 32 ssa_5 = load_const (0x3fb33333 /* 1.400000 */)
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_7 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_8 = fmul ssa_7, ssa_4
	vec1 32 ssa_9 = fneg ssa_8
	vec1 32 ssa_10 = fadd ssa_3.x, ssa_9
	vec1 32 ssa_11 = mov ssa_3.y
	vec1 32 ssa_12 = fmul ssa_7, ssa_5
	vec1 32 ssa_13 = fneg ssa_12
	vec1 32 ssa_14 = fadd ssa_3.x, ssa_13
	vec1 32 ssa_15 = ffma ssa_7, ssa_5, ssa_3.x
	vec1 32 ssa_16 = ffma ssa_7, ssa_4, ssa_3.x
	vec1 32 ssa_17 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_17, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_18 = deref_var &packed:v_uv[0],v_uv[1] (shader_out float) 
	intrinsic store_deref (ssa_18, ssa_10) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_19 = deref_var &packed:v_uv[0],v_uv[1]@0 (shader_out float) 
	intrinsic store_deref (ssa_19, ssa_14) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_20 = deref_var &packed:v_uv[2],v_uv[3] (shader_out float) 
	vec1 32 ssa_21 = mov ssa_3.x
	intrinsic store_deref (ssa_20, ssa_21) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_22 = deref_var &packed:v_uv[2],v_uv[3]@1 (shader_out float) 
	intrinsic store_deref (ssa_22, ssa_15) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_23 = deref_var &packed:v_uv[4] (shader_out float) 
	intrinsic store_deref (ssa_23, ssa_16) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_24 = deref_var &packed:v_uv[4]@2 (shader_out float) 
	intrinsic store_deref (ssa_24, ssa_11) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 37
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = ptrtoint float addrspace(6)* %10 to i32
  %52 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %51, i32 0
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 0, i32 0) #3
  %54 = fmul nsz arcp contract float %53, 0xC00A21FF20000000
  %55 = fadd nsz arcp contract float %49, %54
  %56 = fmul nsz arcp contract float %53, 0xBFF6666660000000
  %57 = fadd nsz arcp contract float %49, %56
  %58 = call nsz arcp contract float @llvm.fma.f32(float %53, float 0x3FF6666660000000, float %49) #3
  %59 = call nsz arcp contract float @llvm.fma.f32(float %53, float 0x400A21FF20000000, float %49) #3
  %60 = extractelement <4 x float> %47, i32 0
  %61 = extractelement <4 x float> %47, i32 1
  %62 = extractelement <4 x float> %47, i32 2
  %63 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %60, float %61, float %62, float %63, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %55, float %57, float %49, float %58, i1 false, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 33, i32 15, float %59, float %50, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL36
inputs: 2
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (1, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[0],v_uv[1]@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[4] (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[4]@2 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* packed:v_uv[0],v_uv[1] */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* packed:v_uv[0],v_uv[1] */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* packed:v_uv[4] */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* packed:v_uv[4] */
	vec1 32 ssa_8 = load_const (0x3dacd9e8 /* 0.084400 */)
	vec1 32 ssa_9 = load_const (0x3e9e76c9 /* 0.309500 */)
	vec1 32 ssa_10 = load_const (0x3e594af5 /* 0.212200 */)
	vec1 32 ssa_11 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_12 = vec2 ssa_2, ssa_7
	vec4 32 ssa_13 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_12 (coord)
	vec2 32 ssa_14 = vec2 ssa_3, ssa_7
	vec4 32 ssa_15 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_14 (coord)
	vec1 32 ssa_16 = fmul ssa_15.x, ssa_9
	vec1 32 ssa_17 = fmul ssa_15.y, ssa_9
	vec1 32 ssa_18 = fmul ssa_15.z, ssa_9
	vec1 32 ssa_19 = fmul ssa_15.w, ssa_9
	vec1 32 ssa_20 = ffma ssa_13.x, ssa_8, ssa_16
	vec1 32 ssa_21 = ffma ssa_13.y, ssa_8, ssa_17
	vec1 32 ssa_22 = ffma ssa_13.z, ssa_8, ssa_18
	vec1 32 ssa_23 = ffma ssa_13.w, ssa_8, ssa_19
	vec2 32 ssa_24 = vec2 ssa_4, ssa_7
	vec4 32 ssa_25 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_24 (coord)
	vec1 32 ssa_26 = ffma ssa_25.x, ssa_10, ssa_20
	vec1 32 ssa_27 = ffma ssa_25.y, ssa_10, ssa_21
	vec1 32 ssa_28 = ffma ssa_25.z, ssa_10, ssa_22
	vec1 32 ssa_29 = ffma ssa_25.w, ssa_10, ssa_23
	vec2 32 ssa_30 = vec2 ssa_5, ssa_7
	vec4 32 ssa_31 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_30 (coord)
	vec1 32 ssa_32 = ffma ssa_31.x, ssa_9, ssa_26
	vec1 32 ssa_33 = ffma ssa_31.y, ssa_9, ssa_27
	vec1 32 ssa_34 = ffma ssa_31.z, ssa_9, ssa_28
	vec1 32 ssa_35 = ffma ssa_31.w, ssa_9, ssa_29
	vec2 32 ssa_36 = vec2 ssa_6, ssa_7
	vec4 32 ssa_37 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_36 (coord)
	vec1 32 ssa_38 = ffma ssa_37.x, ssa_8, ssa_32
	vec1 32 ssa_39 = ffma ssa_37.y, ssa_8, ssa_33
	vec1 32 ssa_40 = ffma ssa_37.z, ssa_8, ssa_34
	vec1 32 ssa_41 = ffma ssa_37.w, ssa_8, ssa_35
	vec1 32 ssa_42 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_43 = vec4 ssa_38, ssa_39, ssa_40, ssa_41
	intrinsic store_deref (ssa_42, ssa_43) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 38
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #4
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #4
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 0, i32 1, i32 %5) #4
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #4
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 1, i32 1, i32 %5) #4
  %37 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %38 = load <8 x i32>, <8 x i32> addrspace(6)* %37, align 32, !invariant.load !0
  %39 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %40 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 67, !amdgpu.uniform !0
  %41 = load <4 x i32>, <4 x i32> addrspace(6)* %40, align 16, !invariant.load !0
  %42 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %43 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %28, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %44 = extractelement <4 x float> %43, i32 0
  %45 = fmul nsz arcp contract float %44, 0x3FD3CED920000000
  %46 = extractelement <4 x float> %43, i32 1
  %47 = fmul nsz arcp contract float %46, 0x3FD3CED920000000
  %48 = extractelement <4 x float> %43, i32 2
  %49 = fmul nsz arcp contract float %48, 0x3FD3CED920000000
  %50 = extractelement <4 x float> %43, i32 3
  %51 = fmul nsz arcp contract float %50, 0x3FD3CED920000000
  %52 = extractelement <4 x float> %42, i32 0
  %53 = call nsz arcp contract float @llvm.fma.f32(float %52, float 0x3FB59B3D00000000, float %45) #4
  %54 = extractelement <4 x float> %42, i32 1
  %55 = call nsz arcp contract float @llvm.fma.f32(float %54, float 0x3FB59B3D00000000, float %47) #4
  %56 = extractelement <4 x float> %42, i32 2
  %57 = call nsz arcp contract float @llvm.fma.f32(float %56, float 0x3FB59B3D00000000, float %49) #4
  %58 = extractelement <4 x float> %42, i32 3
  %59 = call nsz arcp contract float @llvm.fma.f32(float %58, float 0x3FB59B3D00000000, float %51) #4
  %60 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %30, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %61 = extractelement <4 x float> %60, i32 0
  %62 = call nsz arcp contract float @llvm.fma.f32(float %61, float 0x3FCB295EA0000000, float %53) #4
  %63 = extractelement <4 x float> %60, i32 1
  %64 = call nsz arcp contract float @llvm.fma.f32(float %63, float 0x3FCB295EA0000000, float %55) #4
  %65 = extractelement <4 x float> %60, i32 2
  %66 = call nsz arcp contract float @llvm.fma.f32(float %65, float 0x3FCB295EA0000000, float %57) #4
  %67 = extractelement <4 x float> %60, i32 3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %67, float 0x3FCB295EA0000000, float %59) #4
  %69 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %32, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %70 = extractelement <4 x float> %69, i32 0
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float 0x3FD3CED920000000, float %62) #4
  %72 = extractelement <4 x float> %69, i32 1
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float 0x3FD3CED920000000, float %64) #4
  %74 = extractelement <4 x float> %69, i32 2
  %75 = call nsz arcp contract float @llvm.fma.f32(float %74, float 0x3FD3CED920000000, float %66) #4
  %76 = extractelement <4 x float> %69, i32 3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %76, float 0x3FD3CED920000000, float %68) #4
  %78 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %79 = extractelement <4 x float> %78, i32 0
  %80 = call nsz arcp contract float @llvm.fma.f32(float %79, float 0x3FB59B3D00000000, float %71) #4
  %81 = extractelement <4 x float> %78, i32 1
  %82 = call nsz arcp contract float @llvm.fma.f32(float %81, float 0x3FB59B3D00000000, float %73) #4
  %83 = extractelement <4 x float> %78, i32 2
  %84 = call nsz arcp contract float @llvm.fma.f32(float %83, float 0x3FB59B3D00000000, float %75) #4
  %85 = extractelement <4 x float> %78, i32 3
  %86 = call nsz arcp contract float @llvm.fma.f32(float %85, float 0x3FB59B3D00000000, float %77) #4
  %87 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %88 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %87, float %80, 5
  %89 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %88, float %82, 6
  %90 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %89, float %84, 7
  %91 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %90, float %86, 8
  %92 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %91, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %92
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL37
inputs: 2
outputs: 3
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float pixelHeight (0, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[0],v_uv[1]@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[4] (VARYING_SLOT_VAR1.x, 8, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[4]@2 (VARYING_SLOT_VAR1.y, 8, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x40510ff9 /* 3.266600 */)
	vec1 32 ssa_5 = load_const (0x3fb33333 /* 1.400000 */)
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_7 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_8 = fmul ssa_7, ssa_4
	vec1 32 ssa_9 = fneg ssa_8
	vec1 32 ssa_10 = mov ssa_3.x
	vec1 32 ssa_11 = fadd ssa_3.y, ssa_9
	vec1 32 ssa_12 = fmul ssa_7, ssa_5
	vec1 32 ssa_13 = fneg ssa_12
	vec1 32 ssa_14 = fadd ssa_3.y, ssa_13
	vec1 32 ssa_15 = ffma ssa_7, ssa_5, ssa_3.y
	vec1 32 ssa_16 = ffma ssa_7, ssa_4, ssa_3.y
	vec1 32 ssa_17 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_17, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_18 = deref_var &packed:v_uv[0],v_uv[1] (shader_out float) 
	intrinsic store_deref (ssa_18, ssa_11) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_19 = deref_var &packed:v_uv[0],v_uv[1]@0 (shader_out float) 
	intrinsic store_deref (ssa_19, ssa_14) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_20 = deref_var &packed:v_uv[2],v_uv[3] (shader_out float) 
	vec1 32 ssa_21 = mov ssa_3.y
	intrinsic store_deref (ssa_20, ssa_21) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_22 = deref_var &packed:v_uv[2],v_uv[3]@1 (shader_out float) 
	intrinsic store_deref (ssa_22, ssa_15) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_23 = deref_var &packed:v_uv[4] (shader_out float) 
	intrinsic store_deref (ssa_23, ssa_10) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_24 = deref_var &packed:v_uv[4]@2 (shader_out float) 
	intrinsic store_deref (ssa_24, ssa_16) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 39
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = ptrtoint float addrspace(6)* %10 to i32
  %52 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %51, i32 0
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 0, i32 0) #3
  %54 = fmul nsz arcp contract float %53, 0xC00A21FF20000000
  %55 = fadd nsz arcp contract float %50, %54
  %56 = fmul nsz arcp contract float %53, 0xBFF6666660000000
  %57 = fadd nsz arcp contract float %50, %56
  %58 = call nsz arcp contract float @llvm.fma.f32(float %53, float 0x3FF6666660000000, float %50) #3
  %59 = call nsz arcp contract float @llvm.fma.f32(float %53, float 0x400A21FF20000000, float %50) #3
  %60 = extractelement <4 x float> %47, i32 0
  %61 = extractelement <4 x float> %47, i32 1
  %62 = extractelement <4 x float> %47, i32 2
  %63 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %60, float %61, float %62, float %63, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %55, float %57, float %50, float %58, i1 false, i1 false) #2
  call void @llvm.amdgcn.exp.f32(i32 33, i32 15, float %49, float %59, float undef, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL37
inputs: 2
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (1, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[0],v_uv[1]@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[4] (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[4]@2 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* packed:v_uv[0],v_uv[1] */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* packed:v_uv[0],v_uv[1] */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* packed:v_uv[4] */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* packed:v_uv[4] */
	vec1 32 ssa_8 = load_const (0x3dacd9e8 /* 0.084400 */)
	vec1 32 ssa_9 = load_const (0x3e9e76c9 /* 0.309500 */)
	vec1 32 ssa_10 = load_const (0x3e594af5 /* 0.212200 */)
	vec1 32 ssa_11 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_12 = vec2 ssa_6, ssa_2
	vec4 32 ssa_13 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_12 (coord)
	vec2 32 ssa_14 = vec2 ssa_6, ssa_3
	vec4 32 ssa_15 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_14 (coord)
	vec1 32 ssa_16 = fmul ssa_15.x, ssa_9
	vec1 32 ssa_17 = fmul ssa_15.y, ssa_9
	vec1 32 ssa_18 = fmul ssa_15.z, ssa_9
	vec1 32 ssa_19 = fmul ssa_15.w, ssa_9
	vec1 32 ssa_20 = ffma ssa_13.x, ssa_8, ssa_16
	vec1 32 ssa_21 = ffma ssa_13.y, ssa_8, ssa_17
	vec1 32 ssa_22 = ffma ssa_13.z, ssa_8, ssa_18
	vec1 32 ssa_23 = ffma ssa_13.w, ssa_8, ssa_19
	vec2 32 ssa_24 = vec2 ssa_6, ssa_4
	vec4 32 ssa_25 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_24 (coord)
	vec1 32 ssa_26 = ffma ssa_25.x, ssa_10, ssa_20
	vec1 32 ssa_27 = ffma ssa_25.y, ssa_10, ssa_21
	vec1 32 ssa_28 = ffma ssa_25.z, ssa_10, ssa_22
	vec1 32 ssa_29 = ffma ssa_25.w, ssa_10, ssa_23
	vec2 32 ssa_30 = vec2 ssa_6, ssa_5
	vec4 32 ssa_31 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_30 (coord)
	vec1 32 ssa_32 = ffma ssa_31.x, ssa_9, ssa_26
	vec1 32 ssa_33 = ffma ssa_31.y, ssa_9, ssa_27
	vec1 32 ssa_34 = ffma ssa_31.z, ssa_9, ssa_28
	vec1 32 ssa_35 = ffma ssa_31.w, ssa_9, ssa_29
	vec2 32 ssa_36 = vec2 ssa_6, ssa_7
	vec4 32 ssa_37 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_36 (coord)
	vec1 32 ssa_38 = ffma ssa_37.x, ssa_8, ssa_32
	vec1 32 ssa_39 = ffma ssa_37.y, ssa_8, ssa_33
	vec1 32 ssa_40 = ffma ssa_37.z, ssa_8, ssa_34
	vec1 32 ssa_41 = ffma ssa_37.w, ssa_8, ssa_35
	vec1 32 ssa_42 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_43 = vec4 ssa_38, ssa_39, ssa_40, ssa_41
	intrinsic store_deref (ssa_42, ssa_43) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 40
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #4
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #4
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 0, i32 1, i32 %5) #4
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #4
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 1, i32 1, i32 %5) #4
  %37 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %38 = load <8 x i32>, <8 x i32> addrspace(6)* %37, align 32, !invariant.load !0
  %39 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %40 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %39, i32 67, !amdgpu.uniform !0
  %41 = load <4 x i32>, <4 x i32> addrspace(6)* %40, align 16, !invariant.load !0
  %42 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %26, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %43 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %28, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %44 = extractelement <4 x float> %43, i32 0
  %45 = fmul nsz arcp contract float %44, 0x3FD3CED920000000
  %46 = extractelement <4 x float> %43, i32 1
  %47 = fmul nsz arcp contract float %46, 0x3FD3CED920000000
  %48 = extractelement <4 x float> %43, i32 2
  %49 = fmul nsz arcp contract float %48, 0x3FD3CED920000000
  %50 = extractelement <4 x float> %43, i32 3
  %51 = fmul nsz arcp contract float %50, 0x3FD3CED920000000
  %52 = extractelement <4 x float> %42, i32 0
  %53 = call nsz arcp contract float @llvm.fma.f32(float %52, float 0x3FB59B3D00000000, float %45) #4
  %54 = extractelement <4 x float> %42, i32 1
  %55 = call nsz arcp contract float @llvm.fma.f32(float %54, float 0x3FB59B3D00000000, float %47) #4
  %56 = extractelement <4 x float> %42, i32 2
  %57 = call nsz arcp contract float @llvm.fma.f32(float %56, float 0x3FB59B3D00000000, float %49) #4
  %58 = extractelement <4 x float> %42, i32 3
  %59 = call nsz arcp contract float @llvm.fma.f32(float %58, float 0x3FB59B3D00000000, float %51) #4
  %60 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %30, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %61 = extractelement <4 x float> %60, i32 0
  %62 = call nsz arcp contract float @llvm.fma.f32(float %61, float 0x3FCB295EA0000000, float %53) #4
  %63 = extractelement <4 x float> %60, i32 1
  %64 = call nsz arcp contract float @llvm.fma.f32(float %63, float 0x3FCB295EA0000000, float %55) #4
  %65 = extractelement <4 x float> %60, i32 2
  %66 = call nsz arcp contract float @llvm.fma.f32(float %65, float 0x3FCB295EA0000000, float %57) #4
  %67 = extractelement <4 x float> %60, i32 3
  %68 = call nsz arcp contract float @llvm.fma.f32(float %67, float 0x3FCB295EA0000000, float %59) #4
  %69 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %32, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %70 = extractelement <4 x float> %69, i32 0
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float 0x3FD3CED920000000, float %62) #4
  %72 = extractelement <4 x float> %69, i32 1
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float 0x3FD3CED920000000, float %64) #4
  %74 = extractelement <4 x float> %69, i32 2
  %75 = call nsz arcp contract float @llvm.fma.f32(float %74, float 0x3FD3CED920000000, float %66) #4
  %76 = extractelement <4 x float> %69, i32 3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %76, float 0x3FD3CED920000000, float %68) #4
  %78 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %34, float %36, <8 x i32> %38, <4 x i32> %41, i1 false, i32 0, i32 0) #5
  %79 = extractelement <4 x float> %78, i32 0
  %80 = call nsz arcp contract float @llvm.fma.f32(float %79, float 0x3FB59B3D00000000, float %71) #4
  %81 = extractelement <4 x float> %78, i32 1
  %82 = call nsz arcp contract float @llvm.fma.f32(float %81, float 0x3FB59B3D00000000, float %73) #4
  %83 = extractelement <4 x float> %78, i32 2
  %84 = call nsz arcp contract float @llvm.fma.f32(float %83, float 0x3FB59B3D00000000, float %75) #4
  %85 = extractelement <4 x float> %78, i32 3
  %86 = call nsz arcp contract float @llvm.fma.f32(float %85, float 0x3FB59B3D00000000, float %77) #4
  %87 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %88 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %87, float %80, 5
  %89 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %88, float %82, 6
  %90 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %89, float %84, 7
  %91 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %90, float %86, 8
  %92 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %91, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %92
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL40
inputs: 2
outputs: 2
uniforms: 1
shared: 0
decl_var uniform INTERP_MODE_NONE float pixelWidth (0, 0, 0)
decl_var uniform INTERP_MODE_NONE float pixelHeight (1, 1, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec2 uv0 (VERT_ATTRIB_GENERIC4.xy, 4, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@0 (VARYING_SLOT_VAR0.z, 4, 0)
decl_var shader_out INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &uv0 (shader_in vec2) 
	vec2 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_5 = intrinsic load_ubo (ssa_4, ssa_4) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_6 = load_const (0x00000004 /* 0.000000 */)
	vec1 32 ssa_7 = intrinsic load_ubo (ssa_4, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_8 = fneg ssa_5
	vec1 32 ssa_9 = fneg ssa_7
	vec1 32 ssa_10 = fadd ssa_3.x, ssa_8
	vec1 32 ssa_11 = fadd ssa_3.y, ssa_9
	vec1 32 ssa_12 = fadd ssa_7, ssa_3.y
	vec1 32 ssa_13 = fadd ssa_5, ssa_3.x
	vec1 32 ssa_14 = deref_var &gl_Position (shader_out vec4) 
	intrinsic store_deref (ssa_14, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_15 = deref_var &packed:v_uv[0],v_uv[1] (shader_out float) 
	intrinsic store_deref (ssa_15, ssa_10) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_16 = deref_var &packed:v_uv[2],v_uv[3] (shader_out float) 
	intrinsic store_deref (ssa_16, ssa_11) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_17 = deref_var &packed:v_uv[2],v_uv[3]@0 (shader_out float) 
	intrinsic store_deref (ssa_17, ssa_13) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_18 = deref_var &packed:v_uv[2],v_uv[3]@1 (shader_out float) 
	intrinsic store_deref (ssa_18, ssa_12) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 41
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, i32 %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %33 = and i32 %3, 251658240
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %35 = lshr i32 %2, 12
  %36 = and i32 %35, 511
  %37 = lshr i32 %2, 10
  %38 = and i32 %37, 2093056
  %39 = or i32 %38, %36
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %39) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %40 = lshr i32 %3, 8
  %41 = and i32 %40, 255
  %42 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %43 = icmp ult i32 %42, %41
  br i1 %43, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %44 = bitcast i32 %22 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %44, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %45 = and i32 %3, 255
  %46 = icmp ult i32 %42, %45
  br i1 %46, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %47 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %31, i32 0, i32 0, i32 0) #3
  %48 = call nsz arcp contract <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32> %21, i32 %32, i32 0, i32 0, i32 0) #3
  %49 = extractelement <2 x float> %48, i32 0
  %50 = extractelement <2 x float> %48, i32 1
  %51 = ptrtoint float addrspace(6)* %10 to i32
  %52 = insertelement <4 x i32> <i32 undef, i32 32768, i32 16, i32 822177708>, i32 %51, i32 0
  %53 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 0, i32 0) #3
  %54 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %52, i32 4, i32 0) #3
  %55 = fsub nsz arcp contract float %49, %53
  %56 = fsub nsz arcp contract float %50, %54
  %57 = fadd nsz arcp contract float %54, %50
  %58 = fadd nsz arcp contract float %53, %49
  %59 = extractelement <4 x float> %47, i32 0
  %60 = extractelement <4 x float> %47, i32 1
  %61 = extractelement <4 x float> %47, i32 2
  %62 = extractelement <4 x float> %47, i32 3
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %59, float %60, float %61, float %62, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %55, float %56, float %58, float %57, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.amdgcn.struct.buffer.load.format.v2f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL40
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (2, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[0],v_uv[1] (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3] (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@0 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float packed:v_uv[2],v_uv[3]@1 (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* packed:v_uv[0],v_uv[1] */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* packed:v_uv[2],v_uv[3] */
	vec1 32 ssa_6 = load_const (0x3e800000 /* 0.250000 */)
	vec1 32 ssa_7 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_8 = vec2 ssa_2, ssa_3
	vec4 32 ssa_9 = tex ssa_7 (texture_deref), ssa_7 (sampler_deref), ssa_8 (coord)
	vec2 32 ssa_10 = vec2 ssa_2, ssa_5
	vec4 32 ssa_11 = tex ssa_7 (texture_deref), ssa_7 (sampler_deref), ssa_10 (coord)
	vec1 32 ssa_12 = fadd ssa_9.x, ssa_11.x
	vec1 32 ssa_13 = fmul ssa_6, ssa_12
	vec1 32 ssa_14 = fadd ssa_9.y, ssa_11.y
	vec1 32 ssa_15 = fmul ssa_6, ssa_14
	vec1 32 ssa_16 = fadd ssa_9.z, ssa_11.z
	vec1 32 ssa_17 = fmul ssa_6, ssa_16
	vec1 32 ssa_18 = fadd ssa_9.w, ssa_11.w
	vec1 32 ssa_19 = fmul ssa_6, ssa_18
	vec2 32 ssa_20 = vec2 ssa_4, ssa_3
	vec4 32 ssa_21 = tex ssa_7 (texture_deref), ssa_7 (sampler_deref), ssa_20 (coord)
	vec1 32 ssa_22 = ffma ssa_21.x, ssa_6, ssa_13
	vec1 32 ssa_23 = ffma ssa_21.y, ssa_6, ssa_15
	vec1 32 ssa_24 = ffma ssa_21.z, ssa_6, ssa_17
	vec1 32 ssa_25 = ffma ssa_21.w, ssa_6, ssa_19
	vec2 32 ssa_26 = vec2 ssa_4, ssa_5
	vec4 32 ssa_27 = tex ssa_7 (texture_deref), ssa_7 (sampler_deref), ssa_26 (coord)
	vec1 32 ssa_28 = ffma ssa_27.x, ssa_6, ssa_22
	vec1 32 ssa_29 = ffma ssa_27.y, ssa_6, ssa_23
	vec1 32 ssa_30 = ffma ssa_27.z, ssa_6, ssa_24
	vec1 32 ssa_31 = ffma ssa_27.w, ssa_6, ssa_25
	vec1 32 ssa_32 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_33 = vec4 ssa_28, ssa_29, ssa_30, ssa_31
	intrinsic store_deref (ssa_32, ssa_33) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 42
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 0, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 1, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 2, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 3, i32 0, i32 %5) #4
  %33 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %34 = load <8 x i32>, <8 x i32> addrspace(6)* %33, align 32, !invariant.load !0
  %35 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %36 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %35, i32 67, !amdgpu.uniform !0
  %37 = load <4 x i32>, <4 x i32> addrspace(6)* %36, align 16, !invariant.load !0
  %38 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %28, <8 x i32> %34, <4 x i32> %37, i1 false, i32 0, i32 0) #5
  %39 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %26, float %32, <8 x i32> %34, <4 x i32> %37, i1 false, i32 0, i32 0) #5
  %40 = extractelement <4 x float> %38, i32 0
  %41 = extractelement <4 x float> %39, i32 0
  %42 = fadd nsz arcp contract float %40, %41
  %43 = fmul nsz arcp contract float %42, 2.500000e-01
  %44 = extractelement <4 x float> %38, i32 1
  %45 = extractelement <4 x float> %39, i32 1
  %46 = fadd nsz arcp contract float %44, %45
  %47 = fmul nsz arcp contract float %46, 2.500000e-01
  %48 = extractelement <4 x float> %38, i32 2
  %49 = extractelement <4 x float> %39, i32 2
  %50 = fadd nsz arcp contract float %48, %49
  %51 = fmul nsz arcp contract float %50, 2.500000e-01
  %52 = extractelement <4 x float> %38, i32 3
  %53 = extractelement <4 x float> %39, i32 3
  %54 = fadd nsz arcp contract float %52, %53
  %55 = fmul nsz arcp contract float %54, 2.500000e-01
  %56 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %30, float %28, <8 x i32> %34, <4 x i32> %37, i1 false, i32 0, i32 0) #5
  %57 = extractelement <4 x float> %56, i32 0
  %58 = call nsz arcp contract float @llvm.fma.f32(float %57, float 2.500000e-01, float %43) #4
  %59 = extractelement <4 x float> %56, i32 1
  %60 = call nsz arcp contract float @llvm.fma.f32(float %59, float 2.500000e-01, float %47) #4
  %61 = extractelement <4 x float> %56, i32 2
  %62 = call nsz arcp contract float @llvm.fma.f32(float %61, float 2.500000e-01, float %51) #4
  %63 = extractelement <4 x float> %56, i32 3
  %64 = call nsz arcp contract float @llvm.fma.f32(float %63, float 2.500000e-01, float %55) #4
  %65 = call nsz arcp contract <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 15, float %30, float %32, <8 x i32> %34, <4 x i32> %37, i1 false, i32 0, i32 0) #5
  %66 = extractelement <4 x float> %65, i32 0
  %67 = call nsz arcp contract float @llvm.fma.f32(float %66, float 2.500000e-01, float %58) #4
  %68 = extractelement <4 x float> %65, i32 1
  %69 = call nsz arcp contract float @llvm.fma.f32(float %68, float 2.500000e-01, float %60) #4
  %70 = extractelement <4 x float> %65, i32 2
  %71 = call nsz arcp contract float @llvm.fma.f32(float %70, float 2.500000e-01, float %62) #4
  %72 = extractelement <4 x float> %65, i32 3
  %73 = call nsz arcp contract float @llvm.fma.f32(float %72, float 2.500000e-01, float %64) #4
  %74 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %75 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %74, float %67, 5
  %76 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %75, float %69, 6
  %77 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %76, float %71, 7
  %78 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %77, float %73, 8
  %79 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %78, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %79
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }
attributes #5 = { convergent nounwind readnone }

!0 = !{}

shader: MESA_SHADER_VERTEX
name: GLSL45
inputs: 3
outputs: 2
uniforms: 5
shared: 0
decl_var uniform INTERP_MODE_NONE mat4 ViewProjMatrix (0, 0, 0)
decl_var uniform INTERP_MODE_NONE float fFogDensity (1, 16, 0)
decl_var uniform INTERP_MODE_NONE float fFogFalloff (2, 17, 0)
decl_var uniform INTERP_MODE_NONE float fFogTone (3, 18, 0)
decl_var shader_in INTERP_MODE_NONE vec4 position (VERT_ATTRIB_GENERIC0.xyzw, 0, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color0 (VERT_ATTRIB_GENERIC2.xyzw, 4, 0)
decl_var shader_in INTERP_MODE_NONE vec4 color1 (VERT_ATTRIB_GENERIC3.xyzw, 8, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_Position (VARYING_SLOT_POS.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_NONE float v_add (VARYING_SLOT_VAR0.x, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_add@0 (VARYING_SLOT_VAR0.y, 4, 0)
decl_var shader_out INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.z, 4, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = deref_var &position (shader_in vec4) 
	vec4 32 ssa_1 = intrinsic load_deref (ssa_0) (0) /* access=0 */
	vec1 32 ssa_2 = deref_var &color0 (shader_in vec4) 
	vec4 32 ssa_3 = intrinsic load_deref (ssa_2) (0) /* access=0 */
	vec1 32 ssa_4 = deref_var &color1 (shader_in vec4) 
	vec4 32 ssa_5 = intrinsic load_deref (ssa_4) (0) /* access=0 */
	vec1 32 ssa_6 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_7 = load_const (0x3f800000 /* 1.000000 */)
	vec1 32 ssa_8 = load_const (0x3fb8aa3b /* 1.442695 */)
	vec1 32 ssa_9 = load_const (0x40000000 /* 2.000000 */)
	vec1 32 ssa_10 = load_const (0xbf800000 /* -1.000000 */)
	vec4 32 ssa_11 = intrinsic load_ubo (ssa_6, ssa_6) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_12 = load_const (0x00000010 /* 0.000000 */)
	vec4 32 ssa_13 = intrinsic load_ubo (ssa_6, ssa_12) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_14 = fmul ssa_13.x, ssa_1.y
	vec1 32 ssa_15 = fmul ssa_13.y, ssa_1.y
	vec1 32 ssa_16 = fmul ssa_13.z, ssa_1.y
	vec1 32 ssa_17 = fmul ssa_13.w, ssa_1.y
	vec1 32 ssa_18 = ffma ssa_11.x, ssa_1.x, ssa_14
	vec1 32 ssa_19 = ffma ssa_11.y, ssa_1.x, ssa_15
	vec1 32 ssa_20 = ffma ssa_11.z, ssa_1.x, ssa_16
	vec1 32 ssa_21 = ffma ssa_11.w, ssa_1.x, ssa_17
	vec1 32 ssa_22 = load_const (0x00000020 /* 0.000000 */)
	vec4 32 ssa_23 = intrinsic load_ubo (ssa_6, ssa_22) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_24 = ffma ssa_23.x, ssa_1.z, ssa_18
	vec1 32 ssa_25 = ffma ssa_23.y, ssa_1.z, ssa_19
	vec1 32 ssa_26 = ffma ssa_23.z, ssa_1.z, ssa_20
	vec1 32 ssa_27 = ffma ssa_23.w, ssa_1.z, ssa_21
	vec1 32 ssa_28 = load_const (0x00000030 /* 0.000000 */)
	vec4 32 ssa_29 = intrinsic load_ubo (ssa_6, ssa_28) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_30 = ffma ssa_29.x, ssa_1.w, ssa_24
	vec1 32 ssa_31 = ffma ssa_29.y, ssa_1.w, ssa_25
	vec1 32 ssa_32 = ffma ssa_29.z, ssa_1.w, ssa_26
	vec1 32 ssa_33 = ffma ssa_29.w, ssa_1.w, ssa_27
	vec1 32 ssa_34 = fmax ssa_6, ssa_1.z
	vec1 32 ssa_35 = load_const (0x00000040 /* 0.000000 */)
	vec1 32 ssa_36 = intrinsic load_ubo (ssa_6, ssa_35) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_37 = fmul ssa_34, ssa_36
	vec1 32 ssa_38 = load_const (0x00000044 /* 0.000000 */)
	vec1 32 ssa_39 = intrinsic load_ubo (ssa_6, ssa_38) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_40 = fpow ssa_37, ssa_39
	vec1 32 ssa_41 = fmul ssa_40, ssa_8
	vec1 32 ssa_42 = fmul ssa_41, ssa_5.y
	vec1 32 ssa_43 = fneg ssa_42
	vec1 32 ssa_44 = fexp2 ssa_43
	vec1 32 ssa_45 = fneg ssa_44
	vec1 32 ssa_46 = fadd ssa_7, ssa_45
	vec1 32 ssa_47 = ffma ssa_9, ssa_5.x, ssa_10
	vec1 32 ssa_48 = fmax ssa_6, ssa_47
	vec1 32 ssa_49 = load_const (0x00000048 /* 0.000000 */)
	vec1 32 ssa_50 = intrinsic load_ubo (ssa_6, ssa_49) (0, 4, 0) /* access=0 */ /* align_mul=4 */ /* align_offset=0 */
	vec1 32 ssa_51 = fmul ssa_46, ssa_50
	vec1 32 ssa_52 = ffma ssa_48, ssa_44, ssa_51
	vec1 32 ssa_53 = fmul ssa_5.w, ssa_52
	vec1 32 ssa_54 = deref_var &gl_Position (shader_out vec4) 
	vec4 32 ssa_55 = vec4 ssa_30, ssa_31, ssa_32, ssa_33
	intrinsic store_deref (ssa_54, ssa_55) (15, 0) /* wrmask=xyzw */ /* access=0 */
	vec1 32 ssa_56 = deref_var &v_add (shader_out float) 
	intrinsic store_deref (ssa_56, ssa_52) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_57 = deref_var &v_add@0 (shader_out float) 
	intrinsic store_deref (ssa_57, ssa_53) (1, 0) /* wrmask=x */ /* access=0 */
	vec1 32 ssa_58 = deref_var &v_mul (shader_out float) 
	vec1 32 ssa_59 = mov ssa_3.w
	intrinsic store_deref (ssa_58, ssa_59) (1, 0) /* wrmask=x */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 43
Vertex Shader as ESGS LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs void @main(float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %6, i32 inreg %7, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %8, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %9, float addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %10, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, <4 x i32> inreg %20, <4 x i32> inreg %21, <4 x i32> inreg %22, i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34) #0 {
main_body:
  call void @llvm.amdgcn.init.exec(i64 -1) #1
  %35 = and i32 %3, 251658240
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %if5020, label %endif5020

if5020:                                           ; preds = %main_body
  %37 = lshr i32 %2, 12
  %38 = and i32 %37, 511
  %39 = lshr i32 %2, 10
  %40 = and i32 %39, 2093056
  %41 = or i32 %40, %38
  call void @llvm.amdgcn.s.sendmsg(i32 9, i32 %41) #2
  br label %endif5020

endif5020:                                        ; preds = %if5020, %main_body
  %42 = lshr i32 %3, 8
  %43 = and i32 %42, 255
  %44 = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0) #3, !range !0
  %45 = icmp ult i32 %44, %43
  br i1 %45, label %if6001, label %endif6001

if6001:                                           ; preds = %endif5020
  %46 = bitcast i32 %23 to float
  call void @llvm.amdgcn.exp.f32(i32 20, i32 1, float %46, float undef, float undef, float undef, i1 true, i1 false) #2
  br label %endif6001

endif6001:                                        ; preds = %if6001, %endif5020
  %47 = and i32 %3, 255
  %48 = icmp ult i32 %44, %47
  br i1 %48, label %if11500, label %endif6002

if11500:                                          ; preds = %endif6001
  %49 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %20, i32 %32, i32 0, i32 0, i32 0) #3
  %50 = extractelement <4 x float> %49, i32 0
  %51 = extractelement <4 x float> %49, i32 1
  %52 = extractelement <4 x float> %49, i32 2
  %53 = extractelement <4 x float> %49, i32 3
  %54 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %21, i32 %33, i32 0, i32 0, i32 0) #3
  %55 = extractelement <4 x float> %54, i32 3
  %56 = call nsz arcp contract <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32> %22, i32 %34, i32 0, i32 0, i32 0) #3
  %57 = extractelement <4 x float> %56, i32 0
  %58 = extractelement <4 x float> %56, i32 1
  %59 = extractelement <4 x float> %56, i32 3
  %60 = ptrtoint float addrspace(6)* %10 to i32
  %61 = insertelement <4 x i32> <i32 undef, i32 32768, i32 80, i32 822177708>, i32 %60, i32 0
  %62 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 0, i32 0) #3
  %63 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 4, i32 0) #3
  %64 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 8, i32 0) #3
  %65 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 12, i32 0) #3
  %66 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 16, i32 0) #3
  %67 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 20, i32 0) #3
  %68 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 24, i32 0) #3
  %69 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 28, i32 0) #3
  %70 = fmul nsz arcp contract float %66, %51
  %71 = fmul nsz arcp contract float %67, %51
  %72 = fmul nsz arcp contract float %68, %51
  %73 = fmul nsz arcp contract float %69, %51
  %74 = call nsz arcp contract float @llvm.fma.f32(float %62, float %50, float %70) #3
  %75 = call nsz arcp contract float @llvm.fma.f32(float %63, float %50, float %71) #3
  %76 = call nsz arcp contract float @llvm.fma.f32(float %64, float %50, float %72) #3
  %77 = call nsz arcp contract float @llvm.fma.f32(float %65, float %50, float %73) #3
  %78 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 32, i32 0) #3
  %79 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 36, i32 0) #3
  %80 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 40, i32 0) #3
  %81 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 44, i32 0) #3
  %82 = call nsz arcp contract float @llvm.fma.f32(float %78, float %52, float %74) #3
  %83 = call nsz arcp contract float @llvm.fma.f32(float %79, float %52, float %75) #3
  %84 = call nsz arcp contract float @llvm.fma.f32(float %80, float %52, float %76) #3
  %85 = call nsz arcp contract float @llvm.fma.f32(float %81, float %52, float %77) #3
  %86 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 48, i32 0) #3
  %87 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 52, i32 0) #3
  %88 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 56, i32 0) #3
  %89 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 60, i32 0) #3
  %90 = call nsz arcp contract float @llvm.fma.f32(float %86, float %53, float %82) #3
  %91 = call nsz arcp contract float @llvm.fma.f32(float %87, float %53, float %83) #3
  %92 = call nsz arcp contract float @llvm.fma.f32(float %88, float %53, float %84) #3
  %93 = call nsz arcp contract float @llvm.fma.f32(float %89, float %53, float %85) #3
  %94 = call nsz arcp contract float @llvm.maxnum.f32(float %52, float 0.000000e+00) #3
  %95 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 64, i32 0) #3
  %96 = fmul nsz arcp contract float %94, %95
  %97 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 68, i32 0) #3
  %98 = call nsz arcp contract float @llvm.pow.f32(float %96, float %97) #3
  %99 = fmul nsz arcp contract float %98, 0xBFF7154760000000
  %100 = fmul nsz arcp contract float %58, %99
  %101 = call nsz arcp contract float @llvm.exp2.f32(float %100) #3
  %102 = fsub nsz arcp contract float 1.000000e+00, %101
  %103 = call nsz arcp contract float @llvm.fma.f32(float %57, float 2.000000e+00, float -1.000000e+00) #3
  %104 = call nsz arcp contract float @llvm.maxnum.f32(float %103, float 0.000000e+00) #3
  %105 = call nsz arcp contract float @llvm.amdgcn.s.buffer.load.f32(<4 x i32> %61, i32 72, i32 0) #3
  %106 = fmul nsz arcp contract float %102, %105
  %107 = call nsz arcp contract float @llvm.fma.f32(float %104, float %101, float %106) #3
  %108 = fmul nsz arcp contract float %59, %107
  call void @llvm.amdgcn.exp.f32(i32 12, i32 15, float %90, float %91, float %92, float %93, i1 true, i1 true) #2
  call void @llvm.amdgcn.exp.f32(i32 32, i32 15, float %107, float %108, float %55, float undef, i1 false, i1 false) #2
  br label %endif6002

endif6002:                                        ; preds = %if11500, %endif6001
  ret void
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec(i64 immarg) #1

; Function Attrs: nounwind
declare void @llvm.amdgcn.s.sendmsg(i32 immarg, i32) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32) #3

; Function Attrs: inaccessiblememonly nounwind
declare void @llvm.amdgcn.exp.f32(i32 immarg, i32 immarg, float, float, float, float, i1 immarg, i1 immarg) #4

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.struct.buffer.load.format.v4f32(<4 x i32>, i32, i32, i32, i32 immarg) #5

; Function Attrs: nounwind readnone
declare float @llvm.amdgcn.s.buffer.load.f32(<4 x i32>, i32, i32 immarg) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.maxnum.f32(float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.pow.f32(float, float) #6

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.exp2.f32(float) #6

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "amdgpu-flat-work-group-size"="128,128" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inaccessiblememonly nounwind }
attributes #5 = { nounwind readonly }
attributes #6 = { nounwind readnone speculatable willreturn }

!0 = !{i32 0, i32 32}

shader: MESA_SHADER_FRAGMENT
name: GLSL45
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_mul */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_add */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_add */
	vec1 32 ssa_5 = undefined
	vec1 32 ssa_6 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_7 = vec4 ssa_3, ssa_4, ssa_5, ssa_2
	intrinsic store_deref (ssa_6, ssa_7) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 44
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 0, i32 %5) #2
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 2, i32 0, i32 %5) #2
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #2
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 0, i32 0, i32 %5) #2
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #2
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 1, i32 0, i32 %5) #2
  %31 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %32 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %31, float %28, 5
  %33 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %32, float %30, 6
  %34 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %33, float undef, 7
  %35 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %34, float %26, 8
  %36 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %35, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %36
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB0_0:
	s_bfe_u32 s32, s3, 0x70000   ; 93A0FF03 00070000
	s_bfm_b32 exec_lo, s32, 0    ; 927E8020
	s_cmp_eq_u32 s32, 32         ; BF06A020
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
	v_mov_b32_e32 v11, v9        ; 7E160309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                   ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                             ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                       ; BE80030A
	s_cmp_lg_u32 s1, 0                                      ; BF078001
	s_cbranch_scc1 BB1_2                                    ; BF850000
	s_lshr_b32 s1, s2, 10                                   ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                               ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                              ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                     ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                     ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                               ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                        ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                         ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                           ; BE813C6A
	s_cbranch_execz BB1_4                                   ; BF880000
BB1_3:
	exp prim v0, off, off, off done                         ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                     ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                           ; 887E017E
	s_and_b32 s1, s3, 0xff                                  ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                         ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                           ; BE813C6A
	s_cbranch_execz BB1_6                                   ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen   ; E00C2000 80050009
	buffer_load_format_xyzw v[4:7], v11, s[28:31], 0 idxen  ; E00C2000 8007040B
	buffer_load_format_xyzw v[8:11], v10, s[24:27], 0 idxen ; E00C2000 8006080A
	s_mov_b32 s3, 0x31016fac                                ; BE8303FF 31016FAC
	s_movk_i32 s2, 0x50                                     ; B0020050
	s_mov_b32 s1, 0x8000                                    ; BE8103FF 00008000
	s_buffer_load_dwordx2 s[4:5], s[0:3], 0x40              ; F4240100 FA000040
	s_buffer_load_dword s16, s[0:3], 0x48                   ; F4200400 FA000048
	s_waitcnt vmcnt(1)                                      ; BF8C3F71
	v_max_f32_e32 v6, 0, v2                                 ; 200C0480
	s_waitcnt lgkmcnt(0)                                    ; BF8CC07F
	v_mul_f32_e32 v6, s4, v6                                ; 100C0C04
	v_log_f32_e32 v6, v6                                    ; 7E0C4F06
	v_mul_legacy_f32_e32 v6, s5, v6                         ; 0E0C0C05
	s_buffer_load_dwordx4 s[4:7], s[0:3], 0x10              ; F4280100 FA000010
	s_buffer_load_dwordx4 s[8:11], s[0:3], 0x0              ; F4280200 FA000000
	s_buffer_load_dwordx4 s[12:15], s[0:3], 0x20            ; F4280300 FA000020
	s_buffer_load_dwordx4 s[0:3], s[0:3], 0x30              ; F4280000 FA000030
	v_exp_f32_e32 v6, v6                                    ; 7E0C4B06
	s_waitcnt vmcnt(0) lgkmcnt(0)                           ; BF8C0070
	v_mul_f32_e32 v8, s5, v1                                ; 10100205
	v_mul_f32_e32 v6, 0xbfb8aa3b, v6                        ; 100C0CFF BFB8AA3B
	v_mul_f32_e32 v9, s6, v1                                ; 10120206
	v_fmac_f32_e32 v8, s9, v0                               ; 56100009
	v_mul_f32_e32 v5, v5, v6                                ; 100A0D05
	v_mul_f32_e32 v6, s4, v1                                ; 100C0204
	v_mul_f32_e32 v1, s7, v1                                ; 10020207
	v_fmac_f32_e32 v9, s10, v0                              ; 5612000A
	v_fmac_f32_e32 v8, s13, v2                              ; 5610040D
	v_exp_f32_e32 v5, v5                                    ; 7E0A4B05
	v_fmac_f32_e32 v6, s8, v0                               ; 560C0008
	v_fmac_f32_e32 v1, s11, v0                              ; 5602000B
	v_fmac_f32_e32 v9, s14, v2                              ; 5612040E
	v_fma_f32 v0, v4, 2.0, -1.0                             ; D54B0000 03CDE904
	v_fmac_f32_e32 v8, s1, v3                               ; 56100601
	v_fmac_f32_e32 v6, s12, v2                              ; 560C040C
	v_fmac_f32_e32 v1, s15, v2                              ; 5602040F
	v_fmac_f32_e32 v9, s2, v3                               ; 56120602
	v_max_f32_e32 v0, 0, v0                                 ; 20000080
	v_fmac_f32_e32 v6, s0, v3                               ; 560C0600
	v_fmac_f32_e32 v1, s3, v3                               ; 56020603
	v_sub_f32_e32 v2, 1.0, v5                               ; 08040AF2
	exp pos0 v6, v8, v9, v1 done vm                         ; F80018CF 01090806
	v_mul_f32_e32 v2, s16, v2                               ; 10040410
	v_fmac_f32_e32 v2, v0, v5                               ; 56040B00
	v_mul_f32_e32 v0, v7, v2                                ; 10000507
	exp param0 v2, v0, v11, v0                              ; F800020F 000B0002
BB1_6:
	s_endpgm                                                ; BF810000

*** SHADER STATS ***
SGPRS: 40
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 400 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 m0, s5                    ; BEFC0305
	v_interp_p1_f32_e32 v0, v2, attr0.x ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y ; C8040102
	v_interp_p1_f32_e32 v2, v2, attr0.z ; C8080202
	v_interp_p2_f32_e32 v0, v3, attr0.x ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y ; C8050103
	v_interp_p2_f32_e32 v2, v3, attr0.z ; C8090203
	v_mov_b32_e32 v3, v2                ; 7E060302
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 8
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 60 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


radeonsi: Compiling shader 45
Vertex Shader Prolog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> @vs_prolog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, i32 inreg %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, i32 inreg %20, i32 inreg %21, i32 inreg %22, i32 inreg %23, i32 inreg %24, i32 inreg %25, i32 inreg %26, i32 inreg %27, i32 inreg %28, i32 inreg %29, i32 inreg %30, i32 inreg %31, i32 inreg %32, i32 inreg %33, i32 inreg %34, i32 inreg %35, i32 %36, i32 %37, i32 %38, i32 %39, i32 %40, i32 %41, i32 %42, i32 %43, i32 %44) #0 {
main_body:
  call void @llvm.amdgcn.init.exec.from.input(i32 %3, i32 0) #1
  %45 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %0, 0
  %46 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %45, i32 %1, 1
  %47 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %46, i32 %2, 2
  %48 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %47, i32 %3, 3
  %49 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %48, i32 %4, 4
  %50 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %49, i32 %5, 5
  %51 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %50, i32 %6, 6
  %52 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %51, i32 %7, 7
  %53 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %52, i32 %8, 8
  %54 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %53, i32 %9, 9
  %55 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %54, i32 %10, 10
  %56 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %55, i32 %11, 11
  %57 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %56, i32 %12, 12
  %58 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %57, i32 %13, 13
  %59 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %58, i32 %14, 14
  %60 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %59, i32 %15, 15
  %61 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %60, i32 %16, 16
  %62 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %61, i32 %17, 17
  %63 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %62, i32 %18, 18
  %64 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %63, i32 %19, 19
  %65 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %64, i32 %20, 20
  %66 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %65, i32 %21, 21
  %67 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %66, i32 %22, 22
  %68 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %67, i32 %23, 23
  %69 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %68, i32 %24, 24
  %70 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %69, i32 %25, 25
  %71 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %70, i32 %26, 26
  %72 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %71, i32 %27, 27
  %73 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %72, i32 %28, 28
  %74 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %73, i32 %29, 29
  %75 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %74, i32 %30, 30
  %76 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %75, i32 %31, 31
  %77 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %76, i32 %32, 32
  %78 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %77, i32 %33, 33
  %79 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %78, i32 %34, 34
  %80 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %79, i32 %35, 35
  %81 = bitcast i32 %36 to float
  %82 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %80, float %81, 36
  %83 = bitcast i32 %37 to float
  %84 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %82, float %83, 37
  %85 = bitcast i32 %38 to float
  %86 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %84, float %85, 38
  %87 = bitcast i32 %39 to float
  %88 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %86, float %87, 39
  %89 = bitcast i32 %40 to float
  %90 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %88, float %89, 40
  %91 = bitcast i32 %41 to float
  %92 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %90, float %91, 41
  %93 = bitcast i32 %42 to float
  %94 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %92, float %93, 42
  %95 = bitcast i32 %43 to float
  %96 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %94, float %95, 43
  %97 = bitcast i32 %44 to float
  %98 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %96, float %97, 44
  %99 = add i32 %41, %13
  %100 = bitcast i32 %99 to float
  %101 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %98, float %100, 45
  %102 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %101, float %100, 46
  %103 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %102, float %100, 47
  %104 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %103, float %100, 48
  ret <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float }> %104
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec.from.input(i32, i32 immarg) #1

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB1_0:
	s_bfe_u32 s36, s3, 0x70000   ; 93A4FF03 00070000
	s_bfm_b32 exec_lo, s36, 0    ; 927E8024
	s_cmp_eq_u32 s36, 32         ; BF06A024
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
	v_mov_b32_e32 v11, v9        ; 7E160309
	v_mov_b32_e32 v12, v9        ; 7E180309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                   ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                             ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                       ; BE80030A
	s_cmp_lg_u32 s1, 0                                      ; BF078001
	s_cbranch_scc1 BB1_2                                    ; BF850000
	s_lshr_b32 s1, s2, 10                                   ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                               ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                              ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                     ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                     ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                               ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                        ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                         ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                           ; BE813C6A
	s_cbranch_execz BB1_4                                   ; BF880000
BB1_3:
	exp prim v0, off, off, off done                         ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                     ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                           ; 887E017E
	s_and_b32 s1, s3, 0xff                                  ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                         ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                           ; BE813C6A
	s_cbranch_execz BB1_6                                   ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen   ; E00C2000 80050009
	buffer_load_format_xyzw v[4:7], v11, s[28:31], 0 idxen  ; E00C2000 8007040B
	buffer_load_format_xyzw v[8:11], v10, s[24:27], 0 idxen ; E00C2000 8006080A
	s_waitcnt vmcnt(0)                                      ; BF8C3F70
	buffer_load_format_xy v[9:10], v12, s[32:35], 0 idxen   ; E0042000 8008090C
	s_mov_b32 s3, 0x31016fac                                ; BE8303FF 31016FAC
	s_movk_i32 s2, 0x60                                     ; B0020060
	s_mov_b32 s1, 0x8000                                    ; BE8103FF 00008000
	s_buffer_load_dwordx2 s[4:5], s[0:3], 0x4c              ; F4240100 FA00004C
	v_nop                                                   ; 7E000000
	s_buffer_load_dwordx2 s[20:21], s[0:3], 0x40            ; F4240500 FA000040
	s_buffer_load_dwordx4 s[8:11], s[0:3], 0x0              ; F4280200 FA000000
	s_buffer_load_dwordx4 s[12:15], s[0:3], 0x20            ; F4280300 FA000020
	s_buffer_load_dword s22, s[0:3], 0x48                   ; F4200580 FA000048
	s_buffer_load_dwordx4 s[16:19], s[0:3], 0x30            ; F4280400 FA000030
	s_waitcnt lgkmcnt(0)                                    ; BF8CC07F
	v_rcp_f32_e32 v13, s20                                  ; 7E1A5414
	v_max_f32_e32 v12, 0, v2                                ; 20180480
	v_add_f32_e32 v14, -1.0, v2                             ; 061C04F3
	v_fma_f32 v17, v4, 2.0, -1.0                            ; D54B0011 03CDE904
	v_add_f32_e32 v19, v4, v4                               ; 06260904
	v_fma_f32 v4, v4, -2.0, 2.0                             ; D54B0004 03D1EB04
	v_mul_f32_e32 v12, s4, v12                              ; 10181804
	v_subrev_f32_e32 v15, s20, v14                          ; 0A1E1C14
	v_log_f32_e32 v12, v12                                  ; 7E184F0C
	v_fmac_f32_e32 v15, 4.0, v6                             ; 561E0CF6
	v_mul_f32_e32 v6, 4.0, v6                               ; 100C0CF6
	v_mul_f32_e32 v13, v15, v13                             ; 101A1B0F
	v_log_f32_e64 v13, |v13|                                ; D5A7010D 0000010D
	v_mul_legacy_f32_e32 v12, s5, v12                       ; 0E181805
	s_buffer_load_dwordx4 s[4:7], s[0:3], 0x10              ; F4280100 FA000010
	s_buffer_load_dword s0, s[0:3], 0x54                    ; F4200000 FA000054
	v_exp_f32_e32 v12, v12                                  ; 7E184B0C
	v_mul_f32_e32 v6, v13, v6                               ; 100C0D0D
	v_sqrt_f32_e64 v15, |v6|                                ; D5B3010F 00000106
	v_cmp_gt_f32_e32 vcc_lo, 0, v6                          ; 7C080C80
	s_waitcnt lgkmcnt(0)                                    ; BF8CC07F
	v_mul_f32_e32 v13, s4, v1                               ; 101A0204
	v_mul_f32_e32 v12, 0xbfb8aa3b, v12                      ; 101818FF BFB8AA3B
	v_mul_f32_e32 v14, s5, v1                               ; 101C0205
	v_mul_f32_e32 v16, s6, v1                               ; 10200206
	v_mul_f32_e32 v1, s7, v1                                ; 10020207
	v_fmac_f32_e32 v13, s8, v0                              ; 561A0008
	v_mul_f32_e32 v5, v5, v12                               ; 100A1905
	v_fmac_f32_e32 v14, s9, v0                              ; 561C0009
	v_fmac_f32_e32 v16, s10, v0                             ; 5620000A
	v_fmac_f32_e32 v1, s11, v0                              ; 5602000B
	v_fmac_f32_e32 v13, s12, v2                             ; 561A040C
	v_exp_f32_e32 v5, v5                                    ; 7E0A4B05
	v_fmac_f32_e32 v14, s13, v2                             ; 561C040D
	v_fmac_f32_e32 v16, s14, v2                             ; 5620040E
	v_fmac_f32_e32 v1, s15, v2                              ; 5602040F
	v_cndmask_b32_e64 v0, 1.0, s22, vcc_lo                  ; D5010000 01A82CF2
	v_mul_f32_e32 v6, s21, v15                              ; 100C1E15
	v_fmac_f32_e32 v13, s16, v3                             ; 561A0610
	v_fmac_f32_e32 v14, s17, v3                             ; 561C0611
	v_fmac_f32_e32 v16, s18, v3                             ; 56200612
	v_fmac_f32_e32 v1, s19, v3                              ; 56020613
	v_mul_f32_e32 v0, v6, v0                                ; 10000106
	v_cmp_le_f32_e32 vcc_lo, 0, v17                         ; 7C062280
	exp pos0 v13, v14, v16, v1 done vm                      ; F80018CF 01100E0D
	v_max_f32_e32 v0, 0, v0                                 ; 20000080
	v_cndmask_b32_e32 v3, v19, v4, vcc_lo                   ; 02060913
	v_sub_f32_e32 v2, 1.0, v5                               ; 08040AF2
	v_max_f32_e32 v4, 0, v17                                ; 20082280
	v_min_f32_e32 v0, 0x40a00000, v0                        ; 1E0000FF 40A00000
	s_waitcnt expcnt(0)                                     ; BF8CFF0F
	v_mul_f32_e32 v1, v3, v5                                ; 10020B03
	v_mul_f32_e32 v2, s0, v2                                ; 10040400
	v_mul_f32_e32 v0, 0x3ecccccd, v0                        ; 100000FF 3ECCCCCD
	v_mul_f32_e32 v3, v8, v1                                ; 10060308
	v_fmac_f32_e32 v2, v4, v5                               ; 56040B04
	v_mul_f32_e32 v4, v7, v1                                ; 10080307
	v_mul_f32_e32 v5, v7, v2                                ; 100A0507
	exp param0 v2, v5, v0, v3                               ; F800020F 03000502
	s_waitcnt vmcnt(0)                                      ; BF8C3F70
	exp param1 v4, v11, v9, v10                             ; F800021F 0A090B04
BB1_6:
	s_endpgm                                                ; BF810000

*** SHADER STATS ***
SGPRS: 40
VGPRS: 24
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 564 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b64 s[6:7], exec                                                               ; BE86047E
	s_wqm_b64 exec, exec                                                                 ; BEFE0A7E
	s_mov_b32 s0, s2                                                                     ; BE800302
	s_mov_b32 s16, s3                                                                    ; BE900303
	s_mov_b32 s3, 0x31016fac                                                             ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                                                     ; BE820390
	s_mov_b32 s1, 0x8000                                                                 ; BE8103FF 00008000
	s_mov_b32 m0, s5                                                                     ; BEFC0305
	s_movk_i32 s17, 0x8000                                                               ; B0118000
	s_buffer_load_dword s0, s[0:3], 0x0                                                  ; F4200000 FA000000
	v_interp_p1_f32_e32 v4, v2, attr0.z                                                  ; C8100202
	v_interp_p1_f32_e32 v0, v2, attr0.x                                                  ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y                                                  ; C8040102
	v_interp_p1_f32_e32 v5, v2, attr0.w                                                  ; C8140302
	v_interp_p1_f32_e32 v13, v2, attr1.z                                                 ; C8340602
	v_interp_p1_f32_e32 v12, v2, attr1.w                                                 ; C8300702
	v_interp_p1_f32_e32 v8, v2, attr1.x                                                  ; C8200402
	v_interp_p1_f32_e32 v9, v2, attr1.y                                                  ; C8240502
	v_interp_p2_f32_e32 v4, v3, attr0.z                                                  ; C8110203
	v_interp_p2_f32_e32 v0, v3, attr0.x                                                  ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y                                                  ; C8050103
	v_interp_p2_f32_e32 v5, v3, attr0.w                                                  ; C8150303
	v_interp_p2_f32_e32 v13, v3, attr1.z                                                 ; C8350603
	v_interp_p2_f32_e32 v12, v3, attr1.w                                                 ; C8310703
	v_interp_p2_f32_e32 v8, v3, attr1.x                                                  ; C8210403
	v_interp_p2_f32_e32 v9, v3, attr1.y                                                  ; C8250503
	s_waitcnt lgkmcnt(0)                                                                 ; BF8CC07F
	v_fma_f32 v10, 0x40200000, v4, s0                                                    ; D54B000A 000208FF 40200000
	s_and_b64 exec, exec, s[6:7]                                                         ; 87FE067E
	s_load_dwordx8 s[8:15], s[16:17], 0x400                                              ; F40C0208 FA000400
	s_load_dwordx4 s[0:3], s[16:17], 0x430                                               ; F4080008 FA000430
	s_waitcnt lgkmcnt(0)                                                                 ; BF8CC07F
	image_sample_b v[2:4], [v10, v13, v12], s[8:15], s[0:3] dmask:0xb dim:SQ_RSRC_IMG_2D ; F0940B0A 0002020A 00000C0D
	s_waitcnt vmcnt(0)                                                                   ; BF8C3F70
	v_fmac_f32_e32 v0, v2, v5                                                            ; 56000B02
	v_fmac_f32_e32 v1, v3, v8                                                            ; 56021103
	v_mul_f32_e32 v3, v4, v9                                                             ; 10061304
	v_mov_b32_e32 v2, 0x7fc00000                                                         ; 7E0402FF 7FC00000
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 24
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 220 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


radeonsi: Compiling shader 46
Vertex Shader Prolog LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_gs <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> @vs_prolog(i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %12, i32 inreg %13, i32 inreg %14, i32 inreg %15, i32 inreg %16, i32 inreg %17, i32 inreg %18, i32 inreg %19, i32 inreg %20, i32 inreg %21, i32 inreg %22, i32 inreg %23, i32 inreg %24, i32 inreg %25, i32 inreg %26, i32 inreg %27, i32 %28, i32 %29, i32 %30, i32 %31, i32 %32, i32 %33, i32 %34, i32 %35, i32 %36) #0 {
main_body:
  call void @llvm.amdgcn.init.exec.from.input(i32 %3, i32 0) #1
  %37 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %0, 0
  %38 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %37, i32 %1, 1
  %39 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %38, i32 %2, 2
  %40 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %39, i32 %3, 3
  %41 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %40, i32 %4, 4
  %42 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %41, i32 %5, 5
  %43 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %42, i32 %6, 6
  %44 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %43, i32 %7, 7
  %45 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %44, i32 %8, 8
  %46 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %45, i32 %9, 9
  %47 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %46, i32 %10, 10
  %48 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %47, i32 %11, 11
  %49 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %48, i32 %12, 12
  %50 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %49, i32 %13, 13
  %51 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %50, i32 %14, 14
  %52 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %51, i32 %15, 15
  %53 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %52, i32 %16, 16
  %54 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %53, i32 %17, 17
  %55 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %54, i32 %18, 18
  %56 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %55, i32 %19, 19
  %57 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %56, i32 %20, 20
  %58 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %57, i32 %21, 21
  %59 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %58, i32 %22, 22
  %60 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %59, i32 %23, 23
  %61 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %60, i32 %24, 24
  %62 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %61, i32 %25, 25
  %63 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %62, i32 %26, 26
  %64 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %63, i32 %27, 27
  %65 = bitcast i32 %28 to float
  %66 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %64, float %65, 28
  %67 = bitcast i32 %29 to float
  %68 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %66, float %67, 29
  %69 = bitcast i32 %30 to float
  %70 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %68, float %69, 30
  %71 = bitcast i32 %31 to float
  %72 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %70, float %71, 31
  %73 = bitcast i32 %32 to float
  %74 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %72, float %73, 32
  %75 = bitcast i32 %33 to float
  %76 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %74, float %75, 33
  %77 = bitcast i32 %34 to float
  %78 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %76, float %77, 34
  %79 = bitcast i32 %35 to float
  %80 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %78, float %79, 35
  %81 = bitcast i32 %36 to float
  %82 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %80, float %81, 36
  %83 = add i32 %33, %13
  %84 = bitcast i32 %83 to float
  %85 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %82, float %84, 37
  %86 = insertvalue <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %85, float %84, 38
  ret <{ i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float }> %86
}

; Function Attrs: convergent nounwind
declare void @llvm.amdgcn.init.exec.from.input(i32, i32 immarg) #1

attributes #0 = { "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { convergent nounwind }

SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s0, s3, 0xf000000                           ; 8700FF03 0F000000
	s_cmp_lg_u32 s0, 0                                    ; BF078000
	s_cbranch_scc1 BB0_2                                  ; BF850000
	s_lshr_b32 s0, s2, 10                                 ; 90008A02
	s_bfe_u32 s1, s2, 0x9000c                             ; 9381FF02 0009000C
	s_and_b32 s0, s0, 0x1ff000                            ; 8700FF00 001FF000
	s_or_b32 m0, s0, s1                                   ; 887C0100
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB0_2:
	s_bfe_u32 s0, s3, 0x80008                             ; 9380FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                       ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                         ; BE803C6A
	s_cbranch_execz BB0_4                                 ; BF880000
BB0_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s0                         ; 887E007E
	s_and_b32 s0, s3, 0xff                                ; 8700FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s0, v1                       ; 7D880200
	s_and_saveexec_b32 s0, vcc_lo                         ; BE803C6A
	s_cbranch_execz BB0_6                                 ; BF880000
BB0_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[4:5], v10, s[24:27], 0 idxen  ; E0042000 8006040A
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0)                                    ; BF8C3F70
	exp param0 v4, v5, v0, v0                             ; F800020F 00000504
BB0_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 184 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b64 s[6:7], exec                                                    ; BE86047E
	s_wqm_b64 exec, exec                                                      ; BEFE0A7E
	s_mov_b32 s0, s3                                                          ; BE800303
	s_movk_i32 s1, 0x8000                                                     ; B0018000
	s_mov_b32 m0, s5                                                          ; BEFC0305
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                     ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                      ; F4080000 FA000430
	v_interp_p1_f32_e32 v0, v2, attr0.x                                       ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y                                       ; C8040102
	v_interp_p2_f32_e32 v0, v3, attr0.x                                       ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y                                       ; C8050103
	s_and_b64 exec, exec, s[6:7]                                              ; 87FE067E
	s_waitcnt lgkmcnt(0)                                                      ; BF8CC07F
	image_sample v[0:3], v[0:1], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00020000
	s_waitcnt vmcnt(0)                                                        ; BF8C3F70
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 16
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 100 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_FRAGMENT
inputs: 1
outputs: 1
uniforms: 0
shared: 0
decl_var shader_in INTERP_MODE_FLAT vec4 in_0 (VARYING_SLOT_VAR0.xyzw, 0, 0)
decl_var shader_out INTERP_MODE_FLAT vec4 out_0 (FRAG_RESULT_DATA0.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec1 32 ssa_0 = load_const (0x00000000 /* 0.000000 */)
	vec4 32 ssa_1 = intrinsic load_input (ssa_0) (0, 0, 160) /* base=0 */ /* component=0 */ /* type=float32 */	/* in_0 */
	vec1 32 ssa_2 = deref_var &out_0 (shader_out vec4) 
	intrinsic store_deref (ssa_2, ssa_1) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 47
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 0, i32 0, i32 %5) #2
  %23 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 1, i32 0, i32 %5) #2
  %24 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 2, i32 0, i32 %5) #2
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.mov(i32 2, i32 3, i32 0, i32 %5) #2
  %26 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %27 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %26, float %22, 5
  %28 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %27, float %23, 6
  %29 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %28, float %24, 7
  %30 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %29, float %25, 8
  %31 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %30, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %31
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.mov(i32, i32 immarg, i32 immarg, i32) #1

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readnone }

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 7
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB2_0:
	s_mov_b32 m0, s5                     ; BEFC0305
	v_interp_mov_f32_e32 v0, p0, attr0.x ; C8020002
	v_interp_mov_f32_e32 v1, p0, attr0.y ; C8060102
	v_interp_mov_f32_e32 v2, p0, attr0.z ; C80A0202
	v_interp_mov_f32_e32 v3, p0, attr0.w ; C80E0302
Shader epilog disassembly:
ps_epilog:
BB0_0:
	v_cvt_pkrtz_f16_f32_e32 v2, v2, v3    ; 5E040702
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	exp mrt0 v0, v0, v2, v2 done compr vm ; F8001C0F 00000200
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0020
*** SHADER STATS ***
SGPRS: 8
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 40 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB0_0:
	s_bfe_u32 s32, s3, 0x70000   ; 93A0FF03 00070000
	s_bfm_b32 exec_lo, s32, 0    ; 927E8020
	s_cmp_eq_u32 s32, 32         ; BF06A020
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
	v_mov_b32_e32 v11, v9        ; 7E160309
Shader main disassembly:
main:
BB0_0:
	s_mov_b32 exec_lo, -1                                  ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                            ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                      ; BE80030A
	s_cmp_lg_u32 s1, 0                                     ; BF078001
	s_cbranch_scc1 BB0_2                                   ; BF850000
	s_lshr_b32 s1, s2, 10                                  ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                              ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                             ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                    ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                    ; BF900009
BB0_2:
	s_bfe_u32 s1, s3, 0x80008                              ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                       ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                        ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                          ; BE813C6A
	s_cbranch_execz BB0_4                                  ; BF880000
BB0_3:
	exp prim v0, off, off, off done                        ; F8000941 00000000
BB0_4:
	s_waitcnt expcnt(0)                                    ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                          ; 887E017E
	s_and_b32 s1, s3, 0xff                                 ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                        ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                          ; BE813C6A
	s_cbranch_execz BB0_6                                  ; BF880000
BB0_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen  ; E00C2000 80050009
	buffer_load_format_xyzw v[4:7], v10, s[24:27], 0 idxen ; E00C2000 8006040A
	s_waitcnt vmcnt(0)                                     ; BF8C3F70
	buffer_load_format_xy v[5:6], v11, s[28:31], 0 idxen   ; E0042000 8007050B
	s_mov_b32 s3, 0x31016fac                               ; BE8303FF 31016FAC
	s_mov_b32 s2, 64                                       ; BE8203C0
	s_mov_b32 s1, 0x8000                                   ; BE8103FF 00008000
	s_buffer_load_dwordx4 s[4:7], s[0:3], 0x10             ; F4280100 FA000010
	s_buffer_load_dwordx4 s[8:11], s[0:3], 0x0             ; F4280200 FA000000
	s_buffer_load_dwordx4 s[12:15], s[0:3], 0x20           ; F4280300 FA000020
	s_buffer_load_dwordx4 s[0:3], s[0:3], 0x30             ; F4280000 FA000030
	s_waitcnt lgkmcnt(0)                                   ; BF8CC07F
	v_mul_f32_e32 v11, s6, v1                              ; 10160206
	v_mul_f32_e32 v9, s4, v1                               ; 10120204
	v_mul_f32_e32 v10, s5, v1                              ; 10140205
	v_mul_f32_e32 v1, s7, v1                               ; 10020207
	v_fmac_f32_e32 v11, s10, v0                            ; 5616000A
	v_fmac_f32_e32 v9, s8, v0                              ; 56120008
	v_fmac_f32_e32 v10, s9, v0                             ; 56140009
	v_fmac_f32_e32 v1, s11, v0                             ; 5602000B
	v_fmac_f32_e32 v11, s14, v2                            ; 5616040E
	v_fmac_f32_e32 v9, s12, v2                             ; 5612040C
	v_fmac_f32_e32 v10, s13, v2                            ; 5614040D
	v_fmac_f32_e32 v1, s15, v2                             ; 5602040F
	v_add_f32_e32 v0, 0x3a83126f, v11                      ; 060016FF 3A83126F
	v_fmac_f32_e32 v9, s0, v3                              ; 56120600
	v_fmac_f32_e32 v10, s1, v3                             ; 56140601
	v_fmac_f32_e32 v1, s3, v3                              ; 56020603
	v_fmac_f32_e32 v0, s2, v3                              ; 56000602
	exp pos0 v9, v10, v0, v1 done vm                       ; F80018CF 01000A09
	s_waitcnt vmcnt(0)                                     ; BF8C3F70
	exp param0 v4, v7, v5, v6                              ; F800020F 06050704
BB0_6:
	s_endpgm                                               ; BF810000

*** SHADER STATS ***
SGPRS: 40
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 328 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b64 s[6:7], exec                                                              ; BE86047E
	v_mov_b32_e32 v14, v16                                                              ; 7E1C0310
	s_wqm_b64 exec, exec                                                                ; BEFE0A7E
	s_mov_b32 s0, s2                                                                    ; BE800302
	s_mov_b32 s32, s3                                                                   ; BEA00303
	s_mov_b32 s3, 0x31016fac                                                            ; BE8303FF 31016FAC
	s_mov_b32 s2, 48                                                                    ; BE8203B0
	s_mov_b32 s1, 0x8000                                                                ; BE8103FF 00008000
	s_mov_b32 m0, s5                                                                    ; BEFC0305
	s_movk_i32 s33, 0x8000                                                              ; B0218000
	s_buffer_load_dwordx2 s[28:29], s[0:3], 0xc                                         ; F4240700 FA00000C
	s_buffer_load_dword s5, s[0:3], 0x14                                                ; F4200140 FA000014
	s_load_dwordx8 s[8:15], s[32:33], 0x400                                             ; F40C0210 FA000400
	s_load_dwordx4 s[36:39], s[32:33], 0x430                                            ; F4080910 FA000430
	v_interp_p1_f32_e32 v1, v2, attr0.z                                                 ; C8040202
	v_interp_p1_f32_e32 v8, v2, attr0.w                                                 ; C8200302
	v_interp_p1_f32_e32 v10, v2, attr0.x                                                ; C8280002
	s_load_dwordx8 s[16:23], s[32:33], 0x440                                            ; F40C0410 FA000440
	v_interp_p1_f32_e32 v5, v2, attr0.y                                                 ; C8140102
	v_interp_p2_f32_e32 v1, v3, attr0.z                                                 ; C8050203
	v_interp_p2_f32_e32 v8, v3, attr0.w                                                 ; C8210303
	v_interp_p2_f32_e32 v10, v3, attr0.x                                                ; C8290003
	s_buffer_load_dwordx2 s[30:31], s[0:3], 0x20                                        ; F4240780 FA000020
	v_interp_p2_f32_e32 v5, v3, attr0.y                                                 ; C8150103
	s_load_dwordx4 s[44:47], s[32:33], 0x470                                            ; F4080B10 FA000470
	s_waitcnt lgkmcnt(0)                                                                ; BF8CC07F
	v_mov_b32_e32 v6, s28                                                               ; 7E0C021C
	v_mul_f32_e32 v0, s29, v12                                                          ; 1000181D
	image_sample_b v[2:3], [v6, v1, v8], s[8:15], s[36:39] dmask:0x9 dim:SQ_RSRC_IMG_2D ; F094090A 01220206 00000801
	v_fma_f32 v1, v13, s30, s31                                                         ; D54B0001 007C3D0D
	v_mul_f32_e32 v1, s5, v1                                                            ; 10020205
	s_and_b64 exec, exec, s[6:7]                                                        ; 87FE067E
	image_sample v0, v[0:1], s[16:23], s[44:47] dmask:0x1 dim:SQ_RSRC_IMG_2D            ; F0800108 01640000
	v_mov_b32_e32 v1, 0                                                                 ; 7E020280
	s_waitcnt vmcnt(0)                                                                  ; BF8C3F70
	v_add_f32_e32 v0, v2, v0                                                            ; 06000102
	v_sub_f32_e32 v2, v10, v0                                                           ; 0804010A
	v_fmac_f32_e32 v0, v5, v2                                                           ; 56000505
	v_mov_b32_e32 v2, v1                                                                ; 7E040301
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf377
SPI_PS_INPUT_ENA  = 0x0302
*** SHADER STATS ***
SGPRS: 48
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 236 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                           ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                     ; BE80030A
	s_cmp_lg_u32 s1, 0                                    ; BF078001
	s_cbranch_scc1 BB1_2                                  ; BF850000
	s_lshr_b32 s1, s2, 10                                 ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                             ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                            ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                   ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                             ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_4                                 ; BF880000
BB1_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                         ; 887E017E
	s_and_b32 s1, s3, 0xff                                ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_6                                 ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[4:5], v10, s[24:27], 0 idxen  ; E0042000 8006040A
	s_mov_b32 s3, 0x31016fac                              ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                      ; BE820390
	s_mov_b32 s1, 0x8000                                  ; BE8103FF 00008000
	s_buffer_load_dwordx2 s[0:1], s[0:3], 0x0             ; F4240000 FA000000
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)               ; BF8C0000
	v_subrev_f32_e32 v0, s0, v4                           ; 0A000800
	v_subrev_f32_e32 v1, s1, v5                           ; 0A020A01
	v_add_f32_e32 v2, s1, v5                              ; 06040A01
	v_add_f32_e32 v3, s0, v4                              ; 06060800
	exp param0 v0, v1, v3, v2                             ; F800020F 02030100
BB1_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 232 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB2_0:
	s_mov_b64 s[6:7], exec                                                        ; BE86047E
	s_wqm_b64 exec, exec                                                          ; BEFE0A7E
	s_mov_b32 s0, s3                                                              ; BE800303
	s_movk_i32 s1, 0x8000                                                         ; B0018000
	s_mov_b32 m0, s5                                                              ; BEFC0305
	s_mov_b32 s5, 0x3e800000                                                      ; BE8503FF 3E800000
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                         ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                          ; F4080000 FA000430
	v_interp_p1_f32_e32 v0, v2, attr0.x                                           ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y                                           ; C8040102
	v_interp_p1_f32_e32 v12, v2, attr0.w                                          ; C8300302
	v_interp_p1_f32_e32 v18, v2, attr0.z                                          ; C8480202
	v_interp_p2_f32_e32 v0, v3, attr0.x                                           ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y                                           ; C8050103
	v_interp_p2_f32_e32 v12, v3, attr0.w                                          ; C8310303
	v_interp_p2_f32_e32 v18, v3, attr0.z                                          ; C8490203
	v_mov_b32_e32 v11, v0                                                         ; 7E160300
	v_mov_b32_e32 v19, v1                                                         ; 7E260301
	s_waitcnt lgkmcnt(0)                                                          ; BF8CC07F
	image_sample v[0:3], v[0:1], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D     ; F0800F08 00020000
	image_sample v[4:7], v[11:12], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 0002040B
	image_sample v[19:22], v[18:19], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00021312
	s_waitcnt vmcnt(1)                                                            ; BF8C3F71
	v_add_f32_e32 v0, v0, v4                                                      ; 06000900
	v_add_f32_e32 v1, v1, v5                                                      ; 06020B01
	v_add_f32_e32 v2, v2, v6                                                      ; 06040D02
	v_add_f32_e32 v3, v3, v7                                                      ; 06060F03
	v_mul_f32_e32 v0, s5, v0                                                      ; 10000005
	v_mul_f32_e32 v1, s5, v1                                                      ; 10020205
	v_mul_f32_e32 v2, s5, v2                                                      ; 10040405
	v_mul_f32_e32 v3, s5, v3                                                      ; 10060605
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v0, s5, v19                                                    ; 56002605
	v_fmac_f32_e32 v1, s5, v20                                                    ; 56022805
	v_fmac_f32_e32 v2, s5, v21                                                    ; 56042A05
	v_fmac_f32_e32 v3, s5, v22                                                    ; 56062C05
	v_mov_b32_e32 v19, v12                                                        ; 7E26030C
	s_and_b64 exec, exec, s[6:7]                                                  ; 87FE067E
	image_sample v[7:10], v[18:19], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D  ; F0800F08 00020712
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v0, s5, v7                                                     ; 56000E05
	v_fmac_f32_e32 v1, s5, v8                                                     ; 56021005
	v_fmac_f32_e32 v2, s5, v9                                                     ; 56041205
	v_fmac_f32_e32 v3, s5, v10                                                    ; 56061405
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 16
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 232 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


shader: MESA_SHADER_FRAGMENT
name: GLSL46
inputs: 2
outputs: 1
uniforms: 0
shared: 0
decl_var uniform INTERP_MODE_NONE sampler2D texture0 (7, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul (VARYING_SLOT_VAR0.w, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add (VARYING_SLOT_VAR0.x, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add@0 (VARYING_SLOT_VAR0.y, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_add@1 (VARYING_SLOT_VAR0.z, 0, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv (VARYING_SLOT_VAR1.z, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_uv@2 (VARYING_SLOT_VAR1.w, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul@3 (VARYING_SLOT_VAR1.x, 1, 0)
decl_var shader_in INTERP_MODE_NONE float v_mul@4 (VARYING_SLOT_VAR1.y, 1, 0)
decl_var shader_out INTERP_MODE_NONE vec4 gl_FragColor (FRAG_RESULT_COLOR.xyzw, 0, 0)
decl_function main (0 params)

impl main {
	block block_0:
	/* preds: */
	vec2 32 ssa_0 = intrinsic load_barycentric_pixel () (0) /* interp_mode=0 */
	vec1 32 ssa_1 = load_const (0x00000000 /* 0.000000 */)
	vec1 32 ssa_2 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 3) /* base=0 */ /* component=3 */	/* v_mul */
	vec1 32 ssa_3 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 0) /* base=0 */ /* component=0 */	/* v_add */
	vec1 32 ssa_4 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 1) /* base=0 */ /* component=1 */	/* v_add */
	vec1 32 ssa_5 = intrinsic load_interpolated_input (ssa_0, ssa_1) (0, 2) /* base=0 */ /* component=2 */	/* v_add */
	vec1 32 ssa_6 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 2) /* base=1 */ /* component=2 */	/* v_uv */
	vec1 32 ssa_7 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 3) /* base=1 */ /* component=3 */	/* v_uv */
	vec1 32 ssa_8 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 0) /* base=1 */ /* component=0 */	/* v_mul */
	vec1 32 ssa_9 = intrinsic load_interpolated_input (ssa_0, ssa_1) (1, 1) /* base=1 */ /* component=1 */	/* v_mul */
	vec1 32 ssa_10 = undefined
	vec1 32 ssa_11 = deref_var &texture0 (uniform sampler2D) 
	vec2 32 ssa_12 = vec2 ssa_6, ssa_7
	vec4 32 ssa_13 = tex ssa_11 (texture_deref), ssa_11 (sampler_deref), ssa_12 (coord)
	vec1 32 ssa_14 = ffma ssa_13.x, ssa_2, ssa_3
	vec1 32 ssa_15 = ffma ssa_13.y, ssa_8, ssa_4
	vec1 32 ssa_16 = ffma ssa_13.z, ssa_10, ssa_5
	vec1 32 ssa_17 = fmul ssa_13.w, ssa_9
	vec1 32 ssa_18 = deref_var &gl_FragColor (shader_out vec4) 
	vec4 32 ssa_19 = vec4 ssa_14, ssa_15, ssa_16, ssa_17
	intrinsic store_deref (ssa_18, ssa_19) (15, 0) /* wrmask=xyzw */ /* access=0 */
	/* succs: block_1 */
	block block_1:
}

radeonsi: Compiling shader 48
Pixel Shader LLVM IR:

; ModuleID = 'mesa-shader'
source_filename = "mesa-shader"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--"

define amdgpu_ps <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> @main(<4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %0, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %1, <4 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %2, <8 x i32> addrspace(6)* inreg noalias dereferenceable(18446744073709551615) %3, i32 inreg %4, i32 inreg %5, <2 x i32> %6, <2 x i32> %7, <2 x i32> %8, <3 x i32> %9, <2 x i32> %10, <2 x i32> %11, <2 x i32> %12, <3 x float> %13, float %14, float %15, float %16, float %17, i32 %18, i32 %19, float %20, i32 %21) #0 {
main_body:
  %22 = bitcast <2 x i32> %7 to <2 x float>
  %23 = extractelement <2 x float> %22, i32 0
  %24 = extractelement <2 x float> %22, i32 1
  %25 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 0, i32 %5) #4
  %26 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %25, float %24, i32 3, i32 0, i32 %5) #4
  %27 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 0, i32 %5) #4
  %28 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %27, float %24, i32 0, i32 0, i32 %5) #4
  %29 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 0, i32 %5) #4
  %30 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %29, float %24, i32 1, i32 0, i32 %5) #4
  %31 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 2, i32 1, i32 %5) #4
  %32 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %31, float %24, i32 2, i32 1, i32 %5) #4
  %33 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 3, i32 1, i32 %5) #4
  %34 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %33, float %24, i32 3, i32 1, i32 %5) #4
  %35 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 0, i32 1, i32 %5) #4
  %36 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %35, float %24, i32 0, i32 1, i32 %5) #4
  %37 = call nsz arcp contract float @llvm.amdgcn.interp.p1(float %23, i32 1, i32 1, i32 %5) #4
  %38 = call nsz arcp contract float @llvm.amdgcn.interp.p2(float %37, float %24, i32 1, i32 1, i32 %5) #4
  %39 = getelementptr inbounds <8 x i32>, <8 x i32> addrspace(6)* %3, i32 32, !amdgpu.uniform !0
  %40 = load <8 x i32>, <8 x i32> addrspace(6)* %39, align 32, !invariant.load !0
  %41 = bitcast <8 x i32> addrspace(6)* %3 to <4 x i32> addrspace(6)*
  %42 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(6)* %41, i32 67, !amdgpu.uniform !0
  %43 = load <4 x i32>, <4 x i32> addrspace(6)* %42, align 16, !invariant.load !0
  %44 = call <3 x float> @llvm.amdgcn.image.sample.2d.v3f32.f32(i32 11, float %32, float %34, <8 x i32> %40, <4 x i32> %43, i1 false, i32 0, i32 0)
  %45 = extractelement <3 x float> %44, i32 0
  %46 = call nsz arcp contract float @llvm.fma.f32(float %45, float %26, float %28) #4
  %47 = extractelement <3 x float> %44, i32 1
  %48 = call nsz arcp contract float @llvm.fma.f32(float %47, float %36, float %30) #4
  %49 = extractelement <3 x float> %44, i32 2
  %50 = fmul nsz arcp contract float %49, %38
  %51 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> undef, i32 %4, 4
  %52 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %51, float %46, 5
  %53 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %52, float %48, 6
  %54 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %53, float 0x7FF8000000000000, 7
  %55 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %54, float %50, 8
  %56 = insertvalue <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %55, float %20, 19
  ret <{ i32, i32, i32, i32, i32, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float }> %56
}

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p1(float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readnone speculatable
declare float @llvm.amdgcn.interp.p2(float, float, i32 immarg, i32 immarg, i32) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.amdgcn.image.sample.2d.v4f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #3

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.amdgcn.image.sample.2d.v3f32.f32(i32 immarg, float, float, <8 x i32>, <4 x i32>, i1 immarg, i32 immarg, i32 immarg) #2

attributes #0 = { "InitialPSInputAddr"="0xb077" "amdgpu-32bit-address-high-bits"="0xffff8000" "no-signed-zeros-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind readnone speculatable willreturn }
attributes #4 = { nounwind readnone }

!0 = !{}

SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b64 s[6:7], exec                                                    ; BE86047E
	s_wqm_b64 exec, exec                                                      ; BEFE0A7E
	s_mov_b32 s0, s3                                                          ; BE800303
	s_movk_i32 s1, 0x8000                                                     ; B0018000
	s_mov_b32 m0, s5                                                          ; BEFC0305
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                     ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                      ; F4080000 FA000430
	v_interp_p1_f32_e32 v9, v2, attr0.w                                       ; C8240302
	v_interp_p1_f32_e32 v0, v2, attr0.x                                       ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y                                       ; C8040102
	v_interp_p1_f32_e32 v4, v2, attr1.z                                       ; C8100602
	v_interp_p1_f32_e32 v5, v2, attr1.w                                       ; C8140702
	v_interp_p1_f32_e32 v6, v2, attr1.x                                       ; C8180402
	v_interp_p1_f32_e32 v8, v2, attr1.y                                       ; C8200502
	v_interp_p2_f32_e32 v9, v3, attr0.w                                       ; C8250303
	v_interp_p2_f32_e32 v0, v3, attr0.x                                       ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y                                       ; C8050103
	v_interp_p2_f32_e32 v4, v3, attr1.z                                       ; C8110603
	v_interp_p2_f32_e32 v5, v3, attr1.w                                       ; C8150703
	v_interp_p2_f32_e32 v6, v3, attr1.x                                       ; C8190403
	v_interp_p2_f32_e32 v8, v3, attr1.y                                       ; C8210503
	s_and_b64 exec, exec, s[6:7]                                              ; 87FE067E
	s_waitcnt lgkmcnt(0)                                                      ; BF8CC07F
	image_sample v[3:5], v[4:5], s[8:15], s[0:3] dmask:0xb dim:SQ_RSRC_IMG_2D ; F0800B08 00020304
	v_mov_b32_e32 v2, 0x7fc00000                                              ; 7E0402FF 7FC00000
	s_waitcnt vmcnt(0)                                                        ; BF8C3F70
	v_fmac_f32_e32 v0, v3, v9                                                 ; 56001303
	v_fmac_f32_e32 v1, v4, v6                                                 ; 56020D04
	v_mul_f32_e32 v3, v5, v8                                                  ; 10061105
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 16
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 160 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                           ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                     ; BE80030A
	s_cmp_lg_u32 s1, 0                                    ; BF078001
	s_cbranch_scc1 BB1_2                                  ; BF850000
	s_lshr_b32 s1, s2, 10                                 ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                             ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                            ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                   ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                             ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_4                                 ; BF880000
BB1_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                         ; 887E017E
	s_and_b32 s1, s3, 0xff                                ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_6                                 ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[4:5], v10, s[24:27], 0 idxen  ; E0042000 8006040A
	s_mov_b32 s3, 0x31016fac                              ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                      ; BE820390
	s_mov_b32 s1, 0x8000                                  ; BE8103FF 00008000
	s_buffer_load_dword s0, s[0:3], 0x0                   ; F4200000 FA000000
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0) lgkmcnt(0)                         ; BF8C0070
	v_fma_f32 v7, 0xc0510ff9, s0, v4                      ; D54B0007 041000FF C0510FF9
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	v_fma_f32 v1, 0xbfb33333, s0, v4                      ; D54B0001 041000FF BFB33333
	v_fma_f32 v2, 0x3fb33333, s0, v4                      ; D54B0002 041000FF 3FB33333
	v_fma_f32 v3, 0x40510ff9, s0, v4                      ; D54B0003 041000FF 40510FF9
	exp param0 v7, v1, v4, v2                             ; F800020F 02040107
	exp param1 v3, v5, v0, v0                             ; F800021F 00000503
BB1_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 276 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b64 s[6:7], exec                                                        ; BE86047E
	s_wqm_b64 exec, exec                                                          ; BEFE0A7E
	s_mov_b32 s0, s3                                                              ; BE800303
	s_movk_i32 s1, 0x8000                                                         ; B0018000
	s_mov_b32 m0, s5                                                              ; BEFC0305
	s_mov_b32 s5, 0x3e9e76c9                                                      ; BE8503FF 3E9E76C9
	s_mov_b32 s16, 0x3dacd9e8                                                     ; BE9003FF 3DACD9E8
	s_mov_b32 s17, 0x3e594af5                                                     ; BE9103FF 3E594AF5
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                         ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                          ; F4080000 FA000430
	v_interp_p1_f32_e32 v13, v2, attr1.y                                          ; C8340502
	v_interp_p1_f32_e32 v0, v2, attr0.y                                           ; C8000102
	v_interp_p1_f32_e32 v12, v2, attr0.x                                          ; C8300002
	v_interp_p1_f32_e32 v22, v2, attr0.z                                          ; C8580202
	v_interp_p1_f32_e32 v20, v2, attr0.w                                          ; C8500302
	v_interp_p2_f32_e32 v13, v3, attr1.y                                          ; C8350503
	v_interp_p2_f32_e32 v0, v3, attr0.y                                           ; C8010103
	v_interp_p2_f32_e32 v12, v3, attr0.x                                          ; C8310003
	v_interp_p2_f32_e32 v22, v3, attr0.z                                          ; C8590203
	v_interp_p2_f32_e32 v20, v3, attr0.w                                          ; C8510303
	v_mov_b32_e32 v1, v13                                                         ; 7E02030D
	v_mov_b32_e32 v23, v13                                                        ; 7E2E030D
	v_mov_b32_e32 v21, v13                                                        ; 7E2A030D
	v_interp_p1_f32_e32 v2, v2, attr1.x                                           ; C8080402
	v_interp_p2_f32_e32 v2, v3, attr1.x                                           ; C8090403
	s_waitcnt lgkmcnt(0)                                                          ; BF8CC07F
	image_sample v[4:7], v[0:1], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D     ; F0800F08 00020400
	image_sample v[9:12], v[12:13], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D  ; F0800F08 0002090C
	image_sample v[15:18], v[22:23], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00020F16
	image_sample v[19:22], v[20:21], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00021314
	v_mov_b32_e32 v3, v13                                                         ; 7E06030D
	s_waitcnt vmcnt(3)                                                            ; BF8C3F73
	v_mul_f32_e32 v0, s5, v4                                                      ; 10000805
	v_mul_f32_e32 v1, s5, v5                                                      ; 10020A05
	v_mul_f32_e32 v4, s5, v6                                                      ; 10080C05
	v_mul_f32_e32 v5, s5, v7                                                      ; 100A0E05
	s_waitcnt vmcnt(2)                                                            ; BF8C3F72
	v_fmac_f32_e32 v0, s16, v9                                                    ; 56001210
	v_fmac_f32_e32 v1, s16, v10                                                   ; 56021410
	v_fmac_f32_e32 v4, s16, v11                                                   ; 56081610
	v_fmac_f32_e32 v5, s16, v12                                                   ; 560A1810
	s_waitcnt vmcnt(1)                                                            ; BF8C3F71
	v_fmac_f32_e32 v0, s17, v15                                                   ; 56001E11
	v_fmac_f32_e32 v1, s17, v16                                                   ; 56022011
	v_fmac_f32_e32 v4, s17, v17                                                   ; 56082211
	v_fmac_f32_e32 v5, s17, v18                                                   ; 560A2411
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v0, s5, v19                                                    ; 56002605
	v_fmac_f32_e32 v1, s5, v20                                                    ; 56022805
	v_fmac_f32_e32 v4, s5, v21                                                    ; 56082A05
	v_fmac_f32_e32 v5, s5, v22                                                    ; 560A2C05
	s_and_b64 exec, exec, s[6:7]                                                  ; 87FE067E
	image_sample v[7:10], v[2:3], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D    ; F0800F08 00020702
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v4, s16, v9                                                    ; 56081210
	v_fmac_f32_e32 v5, s16, v10                                                   ; 560A1410
	v_fmac_f32_e32 v0, s16, v7                                                    ; 56000E10
	v_fmac_f32_e32 v1, s16, v8                                                    ; 56021010
	v_mov_b32_e32 v2, v4                                                          ; 7E040304
	v_mov_b32_e32 v3, v5                                                          ; 7E060305
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 24
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 308 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                           ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                     ; BE80030A
	s_cmp_lg_u32 s1, 0                                    ; BF078001
	s_cbranch_scc1 BB1_2                                  ; BF850000
	s_lshr_b32 s1, s2, 10                                 ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                             ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                            ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                   ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                             ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_4                                 ; BF880000
BB1_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                         ; 887E017E
	s_and_b32 s1, s3, 0xff                                ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_6                                 ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[4:5], v10, s[24:27], 0 idxen  ; E0042000 8006040A
	s_mov_b32 s3, 0x31016fac                              ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                      ; BE820390
	s_mov_b32 s1, 0x8000                                  ; BE8103FF 00008000
	s_buffer_load_dword s0, s[0:3], 0x0                   ; F4200000 FA000000
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)               ; BF8C0000
	v_fma_f32 v0, 0xc0510ff9, s0, v5                      ; D54B0000 041400FF C0510FF9
	v_fma_f32 v7, 0xbfb33333, s0, v5                      ; D54B0007 041400FF BFB33333
	v_fma_f32 v2, 0x3fb33333, s0, v5                      ; D54B0002 041400FF 3FB33333
	v_fma_f32 v3, 0x40510ff9, s0, v5                      ; D54B0003 041400FF 40510FF9
	exp param0 v0, v7, v5, v2                             ; F800020F 02050700
	exp param1 v4, v3, v0, v0                             ; F800021F 00000304
BB1_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 272 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB2_0:
	s_mov_b64 s[6:7], exec                                                        ; BE86047E
	s_wqm_b64 exec, exec                                                          ; BEFE0A7E
	s_mov_b32 s0, s3                                                              ; BE800303
	s_movk_i32 s1, 0x8000                                                         ; B0018000
	s_mov_b32 m0, s5                                                              ; BEFC0305
	s_mov_b32 s5, 0x3e9e76c9                                                      ; BE8503FF 3E9E76C9
	s_mov_b32 s16, 0x3dacd9e8                                                     ; BE9003FF 3DACD9E8
	s_mov_b32 s17, 0x3e594af5                                                     ; BE9103FF 3E594AF5
	s_load_dwordx8 s[8:15], s[0:1], 0x400                                         ; F40C0200 FA000400
	s_load_dwordx4 s[0:3], s[0:1], 0x430                                          ; F4080000 FA000430
	v_interp_p1_f32_e32 v22, v2, attr0.x                                          ; C8580002
	v_interp_p1_f32_e32 v0, v2, attr0.y                                           ; C8000102
	v_interp_p1_f32_e32 v21, v2, attr1.x                                          ; C8540402
	v_interp_p1_f32_e32 v1, v2, attr0.z                                           ; C8040202
	v_interp_p1_f32_e32 v4, v2, attr0.w                                           ; C8100302
	v_interp_p2_f32_e32 v22, v3, attr0.x                                          ; C8590003
	v_interp_p2_f32_e32 v0, v3, attr0.y                                           ; C8010103
	v_interp_p2_f32_e32 v21, v3, attr1.x                                          ; C8550403
	v_interp_p2_f32_e32 v1, v3, attr0.z                                           ; C8050203
	v_interp_p2_f32_e32 v4, v3, attr0.w                                           ; C8110303
	v_interp_p1_f32_e32 v2, v2, attr1.y                                           ; C8080502
	v_interp_p2_f32_e32 v2, v3, attr1.y                                           ; C8090503
	s_waitcnt lgkmcnt(0)                                                          ; BF8CC07F
	image_sample v[6:9], v[21:22], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00020615
	v_mov_b32_e32 v22, v0                                                         ; 7E2C0300
	image_sample v[10:13], v[21:22], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00020A15
	v_mov_b32_e32 v22, v1                                                         ; 7E2C0301
	image_sample v[15:18], v[21:22], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00020F15
	v_mov_b32_e32 v22, v4                                                         ; 7E2C0304
	s_waitcnt vmcnt(1)                                                            ; BF8C3F71
	v_mul_f32_e32 v0, s5, v10                                                     ; 10001405
	v_mul_f32_e32 v1, s5, v11                                                     ; 10021605
	v_mul_f32_e32 v19, s5, v12                                                    ; 10261805
	v_mul_f32_e32 v23, s5, v13                                                    ; 102E1A05
	image_sample v[10:13], v[21:22], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00020A15
	v_fmac_f32_e32 v0, s16, v6                                                    ; 56000C10
	v_fmac_f32_e32 v1, s16, v7                                                    ; 56020E10
	v_fmac_f32_e32 v19, s16, v8                                                   ; 56261010
	v_fmac_f32_e32 v23, s16, v9                                                   ; 562E1210
	v_mov_b32_e32 v22, v2                                                         ; 7E2C0302
	s_waitcnt vmcnt(1)                                                            ; BF8C3F71
	v_fmac_f32_e32 v0, s17, v15                                                   ; 56001E11
	v_fmac_f32_e32 v1, s17, v16                                                   ; 56022011
	v_fmac_f32_e32 v19, s17, v17                                                  ; 56262211
	v_fmac_f32_e32 v23, s17, v18                                                  ; 562E2411
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v0, s5, v10                                                    ; 56001405
	v_fmac_f32_e32 v1, s5, v11                                                    ; 56021605
	v_fmac_f32_e32 v19, s5, v12                                                   ; 56261805
	v_fmac_f32_e32 v23, s5, v13                                                   ; 562E1A05
	s_and_b64 exec, exec, s[6:7]                                                  ; 87FE067E
	image_sample v[6:9], v[21:22], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00020615
	s_waitcnt vmcnt(0)                                                            ; BF8C3F70
	v_fmac_f32_e32 v19, s16, v8                                                   ; 56261010
	v_fmac_f32_e32 v23, s16, v9                                                   ; 562E1210
	v_fmac_f32_e32 v0, s16, v6                                                    ; 56000C10
	v_fmac_f32_e32 v1, s16, v7                                                    ; 56020E10
	v_mov_b32_e32 v2, v19                                                         ; 7E040313
	v_mov_b32_e32 v3, v23                                                         ; 7E060317
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 24
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 304 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                           ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                     ; BE80030A
	s_cmp_lg_u32 s1, 0                                    ; BF078001
	s_cbranch_scc1 BB1_2                                  ; BF850000
	s_lshr_b32 s1, s2, 10                                 ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                             ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                            ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                   ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                             ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_4                                 ; BF880000
BB1_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                         ; 887E017E
	s_and_b32 s1, s3, 0xff                                ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_6                                 ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[6:7], v10, s[24:27], 0 idxen  ; E0042000 8006060A
	s_mov_b32 s3, 0x31016fac                              ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                      ; BE820390
	s_mov_b32 s1, 0x8000                                  ; BE8103FF 00008000
	s_buffer_load_dwordx2 s[0:1], s[0:3], 0x0             ; F4240000 FA000000
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)               ; BF8C0000
	v_fma_f32 v0, -0.5, s0, v6                            ; D54B0000 041800F1
	v_fma_f32 v1, -0.5, s1, v7                            ; D54B0001 041C02F1
	v_fma_f32 v2, 0.5, s0, v6                             ; D54B0002 041800F0
	v_fma_f32 v3, 0.5, s1, v7                             ; D54B0003 041C02F0
	exp param0 v6, v7, v1, v0                             ; F800020F 00010706
	exp param1 v2, v3, v0, v0                             ; F800021F 00000302
BB1_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 256 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b64 s[6:7], exec                                                           ; BE86047E
	s_wqm_b64 exec, exec                                                             ; BEFE0A7E
	s_mov_b32 s24, s3                                                                ; BE980303
	s_movk_i32 s25, 0x8000                                                           ; B0198000
	s_mov_b32 m0, s5                                                                 ; BEFC0305
	s_mov_b32 s5, 0x3e800000                                                         ; BE8503FF 3E800000
	s_load_dwordx8 s[16:23], s[24:25], 0x400                                         ; F40C040C FA000400
	s_load_dwordx4 s[28:31], s[24:25], 0x430                                         ; F408070C FA000430
	v_interp_p1_f32_e32 v1, v2, attr0.z                                              ; C8040202
	v_interp_p1_f32_e32 v0, v2, attr0.w                                              ; C8000302
	v_interp_p1_f32_e32 v12, v2, attr1.x                                             ; C8300402
	s_load_dwordx8 s[8:15], s[24:25], 0x480                                          ; F40C020C FA000480
	s_load_dwordx4 s[0:3], s[24:25], 0x4b0                                           ; F408000C FA0004B0
	v_interp_p2_f32_e32 v1, v3, attr0.z                                              ; C8050203
	v_interp_p2_f32_e32 v0, v3, attr0.w                                              ; C8010303
	v_interp_p2_f32_e32 v12, v3, attr1.x                                             ; C8310403
	v_mov_b32_e32 v13, v1                                                            ; 7E1A0301
	s_waitcnt lgkmcnt(0)                                                             ; BF8CC07F
	image_sample v[19:22], v[0:1], s[16:23], s[28:31] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00E41300
	image_sample v[8:11], v[12:13], s[16:23], s[28:31] dmask:0xf dim:SQ_RSRC_IMG_2D  ; F0800F08 00E4080C
	v_interp_p1_f32_e32 v13, v2, attr1.y                                             ; C8340502
	v_interp_p2_f32_e32 v13, v3, attr1.y                                             ; C8350503
	v_mov_b32_e32 v1, v13                                                            ; 7E02030D
	image_sample v[15:18], v[0:1], s[16:23], s[28:31] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00E40F00
	s_waitcnt vmcnt(1)                                                               ; BF8C3F71
	v_add_f32_e32 v1, v20, v9                                                        ; 06021314
	v_add_f32_e32 v0, v19, v8                                                        ; 06001113
	v_add_f32_e32 v4, v21, v10                                                       ; 06081515
	v_add_f32_e32 v11, v22, v11                                                      ; 06161716
	image_sample v[19:22], v[12:13], s[16:23], s[28:31] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00E4130C
	v_interp_p1_f32_e32 v9, v2, attr0.x                                              ; C8240002
	v_interp_p1_f32_e32 v10, v2, attr0.y                                             ; C8280102
	v_mul_f32_e32 v2, s5, v4                                                         ; 10040805
	v_mul_f32_e32 v0, s5, v0                                                         ; 10000005
	v_mul_f32_e32 v1, s5, v1                                                         ; 10020205
	v_mul_f32_e32 v4, s5, v11                                                        ; 10081605
	v_interp_p2_f32_e32 v9, v3, attr0.x                                              ; C8250003
	v_interp_p2_f32_e32 v10, v3, attr0.y                                             ; C8290103
	s_waitcnt vmcnt(1)                                                               ; BF8C3F71
	v_fmac_f32_e32 v0, s5, v15                                                       ; 56001E05
	v_fmac_f32_e32 v1, s5, v16                                                       ; 56022005
	v_fmac_f32_e32 v2, s5, v17                                                       ; 56042205
	v_fmac_f32_e32 v4, s5, v18                                                       ; 56082405
	s_waitcnt vmcnt(0)                                                               ; BF8C3F70
	v_fmac_f32_e32 v0, s5, v19                                                       ; 56002605
	v_fmac_f32_e32 v1, s5, v20                                                       ; 56022805
	v_fmac_f32_e32 v2, s5, v21                                                       ; 56042A05
	v_fmac_f32_e32 v4, s5, v22                                                       ; 56082C05
	s_and_b64 exec, exec, s[6:7]                                                     ; 87FE067E
	image_sample v3, v[9:10], s[8:15], s[0:3] dmask:0x8 dim:SQ_RSRC_IMG_2D           ; F0800808 00020309
	v_nop                                                                            ; 7E000000
	s_load_dwordx8 s[8:15], s[24:25], 0x440                                          ; F40C020C FA000440
	s_load_dwordx4 s[0:3], s[24:25], 0x470                                           ; F408000C FA000470
	s_waitcnt lgkmcnt(0)                                                             ; BF8CC07F
	image_sample v[7:10], v[9:10], s[8:15], s[0:3] dmask:0xf dim:SQ_RSRC_IMG_2D      ; F0800F08 00020709
	s_waitcnt vmcnt(0)                                                               ; BF8C3F70
	v_sub_f32_e32 v10, v10, v4                                                       ; 0814090A
	v_sub_f32_e32 v5, v7, v0                                                         ; 080A0107
	v_sub_f32_e32 v6, v8, v1                                                         ; 080C0308
	v_sub_f32_e32 v9, v9, v2                                                         ; 08120509
	v_fmac_f32_e32 v4, v3, v10                                                       ; 56081503
	v_fmac_f32_e32 v0, v3, v5                                                        ; 56000B03
	v_fmac_f32_e32 v1, v3, v6                                                        ; 56020D03
	v_fmac_f32_e32 v2, v3, v9                                                        ; 56041303
	v_mov_b32_e32 v3, v4                                                             ; 7E060304
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 32
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 340 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.vs.prolog.instance_divisor_is_one = 0
  part.vs.prolog.instance_divisor_is_fetched = 0
  part.vs.prolog.unpack_instance_id_from_vertex_id = 0
  part.vs.prolog.ls_vgpr_fix = 0
  mono.vs.fetch_opencode = 0
  mono.vs.fix_fetch = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  as_es = 0
  as_ls = 0
  as_ngg = 1
  mono.u.vs_export_prim_id = 0
  opt.vs_as_prim_discard_cs = 0
  opt.cs_prim_type = POINTS
  opt.cs_indexed = 0
  opt.cs_instancing = 0
  opt.cs_primitive_restart = 0
  opt.cs_provoking_vertex_first = 0
  opt.cs_need_correct_orientation = 0
  opt.cs_cull_front = 0
  opt.cs_cull_back = 0
  opt.cs_cull_z = 0
  opt.cs_halfz_clip_space = 0
  opt.kill_outputs = 0x0
  opt.clip_disable = 0
  opt.ngg_culling = 0x0

Vertex Shader as ESGS:
Shader prolog disassembly:
vs_prolog:
BB2_0:
	s_bfe_u32 s28, s3, 0x70000   ; 939CFF03 00070000
	s_bfm_b32 exec_lo, s28, 0    ; 927E801C
	s_cmp_eq_u32 s28, 32         ; BF06A01C
	s_cmov_b32 exec_lo, -1       ; BEFE05C1
	v_add_nc_u32_e32 v9, s13, v5 ; 4A120A0D
	v_mov_b32_e32 v10, v9        ; 7E140309
Shader main disassembly:
main:
BB1_0:
	s_mov_b32 exec_lo, -1                                 ; BEFE03C1
	s_and_b32 s1, s3, 0xf000000                           ; 8701FF03 0F000000
	s_mov_b32 s0, s10                                     ; BE80030A
	s_cmp_lg_u32 s1, 0                                    ; BF078001
	s_cbranch_scc1 BB1_2                                  ; BF850000
	s_lshr_b32 s1, s2, 10                                 ; 90018A02
	s_bfe_u32 s2, s2, 0x9000c                             ; 9382FF02 0009000C
	s_and_b32 s1, s1, 0x1ff000                            ; 8701FF01 001FF000
	s_or_b32 m0, s1, s2                                   ; 887C0201
	s_sendmsg sendmsg(MSG_GS_ALLOC_REQ)                   ; BF900009
BB1_2:
	s_bfe_u32 s1, s3, 0x80008                             ; 9381FF03 00080008
	v_mbcnt_lo_u32_b32_e64 v1, -1, 0                      ; D7650001 000100C1
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_4                                 ; BF880000
BB1_3:
	exp prim v0, off, off, off done                       ; F8000941 00000000
BB1_4:
	s_waitcnt expcnt(0)                                   ; BF8CFF0F
	s_or_b32 exec_lo, exec_lo, s1                         ; 887E017E
	s_and_b32 s1, s3, 0xff                                ; 8701FF03 000000FF
	v_cmp_gt_u32_e32 vcc_lo, s1, v1                       ; 7D880201
	s_and_saveexec_b32 s1, vcc_lo                         ; BE813C6A
	s_cbranch_execz BB1_6                                 ; BF880000
BB1_5:
	buffer_load_format_xyzw v[0:3], v9, s[20:23], 0 idxen ; E00C2000 80050009
	buffer_load_format_xy v[4:5], v10, s[24:27], 0 idxen  ; E0042000 8006040A
	s_mov_b32 s3, 0x31016fac                              ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                      ; BE820390
	s_mov_b32 s1, 0x8000                                  ; BE8103FF 00008000
	s_buffer_load_dwordx4 s[0:3], s[0:3], 0x0             ; F4280000 FA000000
	s_waitcnt vmcnt(1)                                    ; BF8C3F71
	exp pos0 v0, v1, v2, v3 done vm                       ; F80018CF 03020100
	s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)               ; BF8C0000
	v_fma_f32 v2, v4, s0, s2                              ; D54B0002 00080104
	v_fma_f32 v3, v5, s1, s3                              ; D54B0003 000C0305
	exp param0 v4, v5, v2, v3                             ; F800020F 03020504
BB1_6:
	s_endpgm                                              ; BF810000

*** SHADER STATS ***
SGPRS: 32
VGPRS: 16
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 232 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB1_0:
	s_mov_b64 s[6:7], exec                                                      ; BE86047E
	s_wqm_b64 exec, exec                                                        ; BEFE0A7E
	s_mov_b32 s40, s3                                                           ; BEA80303
	s_movk_i32 s41, 0x8000                                                      ; B0298000
	s_mov_b32 m0, s5                                                            ; BEFC0305
	s_mov_b32 s0, s2                                                            ; BE800302
	s_mov_b32 s3, 0x31016fac                                                    ; BE8303FF 31016FAC
	s_mov_b32 s2, 32                                                            ; BE8203A0
	s_load_dwordx8 s[8:15], s[40:41], 0x400                                     ; F40C0214 FA000400
	s_load_dwordx4 s[32:35], s[40:41], 0x430                                    ; F4080814 FA000430
	s_load_dwordx8 s[16:23], s[40:41], 0x440                                    ; F40C0414 FA000440
	s_load_dwordx4 s[44:47], s[40:41], 0x470                                    ; F4080B14 FA000470
	v_interp_p1_f32_e32 v0, v2, attr0.x                                         ; C8000002
	v_interp_p1_f32_e32 v1, v2, attr0.y                                         ; C8040102
	s_load_dwordx8 s[24:31], s[40:41], 0x480                                    ; F40C0614 FA000480
	s_mov_b32 s1, 0x8000                                                        ; BE8103FF 00008000
	v_interp_p2_f32_e32 v0, v3, attr0.x                                         ; C8010003
	v_interp_p2_f32_e32 v1, v3, attr0.y                                         ; C8050103
	s_waitcnt lgkmcnt(0)                                                        ; BF8CC07F
	image_sample v[6:7], v[0:1], s[8:15], s[32:35] dmask:0x3 dim:SQ_RSRC_IMG_2D ; F0800308 01020600
	image_sample v0, v[0:1], s[16:23], s[44:47] dmask:0x2 dim:SQ_RSRC_IMG_2D    ; F0800208 01640000
	s_buffer_load_dword s5, s[0:3], 0x10                                        ; F4200140 FA000010
	v_nop                                                                       ; 7E000000
	s_load_dwordx4 s[20:23], s[40:41], 0x4b0                                    ; F4080514 FA0004B0
	v_interp_p1_f32_e32 v1, v2, attr0.z                                         ; C8040202
	v_interp_p1_f32_e32 v2, v2, attr0.w                                         ; C8080302
	v_interp_p2_f32_e32 v1, v3, attr0.z                                         ; C8050203
	v_interp_p2_f32_e32 v2, v3, attr0.w                                         ; C8090303
	s_waitcnt vmcnt(0)                                                          ; BF8C3F70
	v_add_f32_e32 v0, v7, v0                                                    ; 06000107
	v_add_f32_e32 v0, v6, v0                                                    ; 06000106
	s_waitcnt lgkmcnt(0)                                                        ; BF8CC07F
	v_add_f32_e32 v0, s5, v0                                                    ; 06000005
	s_and_b64 exec, exec, s[6:7]                                                ; 87FE067E
	image_sample v1, v[1:2], s[24:31], s[20:23] dmask:0x1 dim:SQ_RSRC_IMG_2D    ; F0800108 00A60101
	s_buffer_load_dwordx2 s[0:1], s[0:3], 0x0                                   ; F4240000 FA000000
	s_waitcnt lgkmcnt(0)                                                        ; BF8CC07F
	v_fma_f32 v2, v0, s0, s1                                                    ; D54B0002 00040100
	s_waitcnt vmcnt(0)                                                          ; BF8C3F70
	v_fma_f32 v1, v1, 2.0, -1.0                                                 ; D54B0001 03CDE901
	v_fmac_f32_e32 v0, v1, v2                                                   ; 56000501
	v_mov_b32_e32 v1, v0                                                        ; 7E020300
	v_mov_b32_e32 v2, v0                                                        ; 7E040300
	v_mov_b32_e32 v3, v0                                                        ; 7E060300
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 48
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 264 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


SHADER KEY
  part.ps.prolog.color_two_side = 0
  part.ps.prolog.flatshade_colors = 0
  part.ps.prolog.poly_stipple = 0
  part.ps.prolog.force_persp_sample_interp = 0
  part.ps.prolog.force_linear_sample_interp = 0
  part.ps.prolog.force_persp_center_interp = 0
  part.ps.prolog.force_linear_center_interp = 0
  part.ps.prolog.bc_optimize_for_persp = 0
  part.ps.prolog.bc_optimize_for_linear = 0
  part.ps.prolog.samplemask_log_ps_iter = 0
  part.ps.epilog.spi_shader_col_format = 0x4
  part.ps.epilog.color_is_int8 = 0x0
  part.ps.epilog.color_is_int10 = 0x0
  part.ps.epilog.last_cbuf = 0
  part.ps.epilog.alpha_func = 4
  part.ps.epilog.alpha_to_one = 0
  part.ps.epilog.poly_line_smoothing = 0
  part.ps.epilog.clamp_color = 0
  mono.u.ps.interpolate_at_sample_force_center = 0
  mono.u.ps.fbfetch_msaa = 0
  mono.u.ps.fbfetch_is_1D = 0
  mono.u.ps.fbfetch_layered = 0

Pixel Shader:
Shader main disassembly:
main:
BB0_0:
	s_mov_b64 s[6:7], exec                                                           ; BE86047E
	s_wqm_b64 exec, exec                                                             ; BEFE0A7E
	s_mov_b32 s28, s3                                                                ; BE9C0303
	s_movk_i32 s29, 0x8000                                                           ; B01D8000
	s_mov_b32 m0, s5                                                                 ; BEFC0305
	s_mov_b32 s1, 0x3e800000                                                         ; BE8103FF 3E800000
	s_mov_b32 s0, s2                                                                 ; BE800302
	s_load_dwordx8 s[16:23], s[28:29], 0x400                                         ; F40C040E FA000400
	s_load_dwordx4 s[24:27], s[28:29], 0x430                                         ; F408060E FA000430
	v_interp_p1_f32_e32 v1, v2, attr0.z                                              ; C8040202
	v_interp_p1_f32_e32 v0, v2, attr0.w                                              ; C8000302
	v_interp_p1_f32_e32 v12, v2, attr1.x                                             ; C8300402
	s_load_dwordx8 s[8:15], s[28:29], 0x480                                          ; F40C020E FA000480
	v_interp_p2_f32_e32 v1, v3, attr0.z                                              ; C8050203
	v_interp_p2_f32_e32 v0, v3, attr0.w                                              ; C8010303
	v_interp_p2_f32_e32 v12, v3, attr1.x                                             ; C8310403
	v_mov_b32_e32 v13, v1                                                            ; 7E1A0301
	s_waitcnt lgkmcnt(0)                                                             ; BF8CC07F
	image_sample v[19:22], v[0:1], s[16:23], s[24:27] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00C41300
	image_sample v[8:11], v[12:13], s[16:23], s[24:27] dmask:0xf dim:SQ_RSRC_IMG_2D  ; F0800F08 00C4080C
	v_interp_p1_f32_e32 v13, v2, attr1.y                                             ; C8340502
	v_interp_p2_f32_e32 v13, v3, attr1.y                                             ; C8350503
	v_mov_b32_e32 v1, v13                                                            ; 7E02030D
	image_sample v[15:18], v[0:1], s[16:23], s[24:27] dmask:0xf dim:SQ_RSRC_IMG_2D   ; F0800F08 00C40F00
	s_waitcnt vmcnt(1)                                                               ; BF8C3F71
	v_add_f32_e32 v1, v20, v9                                                        ; 06021314
	v_add_f32_e32 v0, v19, v8                                                        ; 06001113
	v_add_f32_e32 v4, v21, v10                                                       ; 06081515
	v_add_f32_e32 v11, v22, v11                                                      ; 06161716
	image_sample v[19:22], v[12:13], s[16:23], s[24:27] dmask:0xf dim:SQ_RSRC_IMG_2D ; F0800F08 00C4130C
	v_nop                                                                            ; 7E000000
	s_load_dwordx4 s[16:19], s[28:29], 0x4b0                                         ; F408040E FA0004B0
	v_interp_p1_f32_e32 v9, v2, attr0.x                                              ; C8240002
	v_interp_p1_f32_e32 v10, v2, attr0.y                                             ; C8280102
	v_mul_f32_e32 v2, s1, v4                                                         ; 10040801
	v_mul_f32_e32 v0, s1, v0                                                         ; 10000001
	v_mul_f32_e32 v1, s1, v1                                                         ; 10020201
	v_mul_f32_e32 v4, s1, v11                                                        ; 10081601
	v_interp_p2_f32_e32 v9, v3, attr0.x                                              ; C8250003
	v_interp_p2_f32_e32 v10, v3, attr0.y                                             ; C8290103
	s_waitcnt vmcnt(1)                                                               ; BF8C3F71
	v_fmac_f32_e32 v0, s1, v15                                                       ; 56001E01
	v_fmac_f32_e32 v1, s1, v16                                                       ; 56022001
	v_fmac_f32_e32 v2, s1, v17                                                       ; 56042201
	v_fmac_f32_e32 v4, s1, v18                                                       ; 56082401
	s_waitcnt vmcnt(0)                                                               ; BF8C3F70
	v_fmac_f32_e32 v0, s1, v19                                                       ; 56002601
	v_fmac_f32_e32 v1, s1, v20                                                       ; 56022801
	v_fmac_f32_e32 v2, s1, v21                                                       ; 56042A01
	v_fmac_f32_e32 v4, s1, v22                                                       ; 56082C01
	s_and_b64 exec, exec, s[6:7]                                                     ; 87FE067E
	s_waitcnt lgkmcnt(0)                                                             ; BF8CC07F
	image_sample v3, v[9:10], s[8:15], s[16:19] dmask:0x8 dim:SQ_RSRC_IMG_2D         ; F0800808 00820309
	v_nop                                                                            ; 7E000000
	s_load_dwordx8 s[8:15], s[28:29], 0x440                                          ; F40C020E FA000440
	s_load_dwordx4 s[16:19], s[28:29], 0x470                                         ; F408040E FA000470
	s_mov_b32 s3, 0x31016fac                                                         ; BE8303FF 31016FAC
	s_mov_b32 s2, 16                                                                 ; BE820390
	s_mov_b32 s1, 0x8000                                                             ; BE8103FF 00008000
	s_buffer_load_dword s0, s[0:3], 0x0                                              ; F4200000 FA000000
	s_waitcnt lgkmcnt(0)                                                             ; BF8CC07F
	image_sample v[7:10], v[9:10], s[8:15], s[16:19] dmask:0xf dim:SQ_RSRC_IMG_2D    ; F0800F08 00820709
	s_waitcnt vmcnt(1)                                                               ; BF8C3F71
	v_max_f32_e32 v3, s0, v3                                                         ; 20060600
	s_waitcnt vmcnt(0)                                                               ; BF8C3F70
	v_sub_f32_e32 v10, v10, v4                                                       ; 0814090A
	v_sub_f32_e32 v5, v7, v0                                                         ; 080A0107
	v_sub_f32_e32 v6, v8, v1                                                         ; 080C0308
	v_sub_f32_e32 v9, v9, v2                                                         ; 08120509
	v_fmac_f32_e32 v4, v3, v10                                                       ; 56081503
	v_fmac_f32_e32 v0, v3, v5                                                        ; 56000B03
	v_fmac_f32_e32 v1, v3, v6                                                        ; 56020D03
	v_fmac_f32_e32 v2, v3, v9                                                        ; 56041303
	v_mov_b32_e32 v3, v4                                                             ; 7E060304
Shader epilog disassembly:
ps_epilog:
BB2_0:
	v_cmp_lt_f32_e32 vcc, s4, v3          ; 7C020604
	s_and_b64 exec, exec, vcc             ; 87FE6A7E
	v_cvt_pkrtz_f16_f32_e32 v0, v0, v1    ; 5E000300
	v_cvt_pkrtz_f16_f32_e32 v1, v2, v3    ; 5E020702
	exp mrt0 v0, v0, v1, v1 done compr vm ; F8001C0F 00000100
	s_endpgm                              ; BF810000

*** SHADER CONFIG ***
SPI_PS_INPUT_ADDR = 0xf077
SPI_PS_INPUT_ENA  = 0x0002
*** SHADER STATS ***
SGPRS: 32
VGPRS: 28
Spilled SGPRs: 0
Spilled VGPRs: 0
Private memory VGPRs: 0
Code Size: 388 bytes
LDS: 0 blocks
Scratch: 0 bytes per wave
Max Waves: 10
********************


Game removed: AppID 48000 "", ProcID 58592 
Game 48000 created interface STEAMAPPLIST_INTERFACE_VERSION001 / AppList
Game 48000 created interface STEAMAPPS_INTERFACE_VERSION006 / Apps
Game 48000 created interface STEAMCONTROLLER_INTERFACE_VERSION / Controller
Game 48000 created interface STEAMHTTP_INTERFACE_VERSION002 / HTTP
Game 48000 created interface STEAMMUSIC_INTERFACE_VERSION001 / Music
Game 48000 created interface STEAMREMOTESTORAGE_INTERFACE_VERSION012 / RemoteStorage
Game 48000 created interface STEAMSCREENSHOTS_INTERFACE_VERSION002 / Screenshots
Game 48000 created interface STEAMUGC_INTERFACE_VERSION002 / UGC
Game 48000 created interface STEAMUNIFIEDMESSAGES_INTERFACE_VERSION001 / UnifiedMessages
Game 48000 created interface STEAMUSERSTATS_INTERFACE_VERSION011 / UserStats
Game 48000 created interface SteamFriends014 / Friends
Game 48000 created interface SteamMatchMaking009 / Matchmaking
Game 48000 created interface SteamMatchMakingServers002 / MatchmakingServers
Game 48000 created interface SteamNetworking005 / Networking
Game 48000 created interface SteamUser017 / User
Game 48000 created interface SteamUtils007 / Utils
Game 48000 method call count for IClientUser::BIsSubscribedApp : 1
Game 48000 method call count for IClientUser::GetSteamID : 5
Game 48000 method call count for IClientUtils::GetAppID : 22
Game 48000 method call count for IClientUtils::RecordSteamInterfaceCreation : 17
Game 48000 method call count for IClientAppManager::GetCurrentLanguage : 2
Game 48000 method call count for IClientUserStats::RequestCurrentStats : 1
Game 48000 method call count for IClientUserStats::GetAchievement : 32
Game 48000 method call count for IClientRemoteStorage::FileWrite : 1
Game 48000 method call count for IClientRemoteStorage::FileRead : 2
Game 48000 method call count for IClientRemoteStorage::GetFileSize : 2
Game 48000 method call count for IClientRemoteStorage::FileExists : 5
Game 48000 method call count for IClientRemoteStorage::FilePersisted : 2
Uploaded AppInterfaceStats to Steam
Exiting app 48000
No cached sticky mapping in ActivateActionSet.Exiting workitem thread
